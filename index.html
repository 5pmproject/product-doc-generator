<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제품 문서 생성 시스템</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Lato:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #f5f1ed 0%, #e8e1d9 100%);
            min-height: 100vh;
            padding: 20px;
            color: #4a4237;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            color: #6b5d52;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .subtitle {
            color: #8b7d6b;
            font-size: 1rem;
            font-weight: 300;
        }

        .progress-container {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .workflow-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .workflow-step {
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f5f1ed;
            font-size: 0.85rem;
            color: #8b7d6b;
            transition: all 0.3s ease;
        }

        .workflow-step.active {
            background: #c9b5a0;
            color: #fff;
            font-weight: 600;
        }

        .workflow-step.completed {
            background: #6b9b6b;
            color: #fff;
        }

        .workflow-arrow {
            color: #c9b5a0;
            font-size: 1.2rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e8e1d9;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #c9b5a0 0%, #a89075 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #8b7d6b;
        }

        .form-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(107, 93, 82, 0.1);
            display: none;
        }

        .form-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .question-number {
            font-family: 'Playfair Display', serif;
            font-size: 3rem;
            color: #c9b5a0;
            opacity: 0.3;
            margin-bottom: 10px;
        }

        .question-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: #6b5d52;
            margin-bottom: 10px;
        }

        .question-desc {
            color: #8b7d6b;
            font-size: 0.95rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .input-group {
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            padding: 16px;
            border: 2px solid #e8e1d9;
            border-radius: 12px;
            font-family: 'Lato', sans-serif;
            font-size: 1rem;
            color: #4a4237;
            background: #fefdfb;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #c9b5a0;
        }

        textarea.error {
            border-color: #d4a08a;
        }

        .char-counter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 0.85rem;
            color: #8b7d6b;
        }

        .char-count {
            font-weight: 600;
        }

        .char-count.warning {
            color: #d4a08a;
        }

        .example-text {
            background: #f5f1ed;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #8b7d6b;
            margin-top: 12px;
            border-left: 3px solid #c9b5a0;
        }

        .example-label {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 16px 32px;
            border: none;
            border-radius: 12px;
            font-family: 'Lato', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9b5a0 0%, #a89075 100%);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(168, 144, 117, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #e8e1d9;
            color: #6b5d52;
        }

        .btn-secondary:hover {
            background: #d9d0c5;
        }

        .auto-save-indicator {
            text-align: center;
            color: #8b7d6b;
            font-size: 0.85rem;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .auto-save-indicator.show {
            opacity: 1;
        }

        .completion-screen {
            display: none;
            text-align: center;
            padding: 60px 40px;
        }

        .completion-screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .completion-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .completion-title {
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            color: #6b5d52;
            margin-bottom: 15px;
        }

        .completion-desc {
            color: #8b7d6b;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        /* BRD 생성 화면 */
        .document-screen {
            display: none;
            padding: 40px;
        }

        .document-screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .document-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e8e1d9;
        }

        .document-title {
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            color: #6b5d52;
        }

        .document-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .badge-generating {
            background: #fff5e6;
            color: #d4a08a;
        }

        .badge-generated {
            background: #e8f5e8;
            color: #6b9b6b;
        }

        .badge-approved {
            background: #c9b5a0;
            color: #fff;
        }

        .generating-animation {
            text-align: center;
            padding: 60px 20px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #e8e1d9;
            border-top-color: #c9b5a0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .generating-text {
            font-size: 1.2rem;
            color: #6b5d52;
            margin-bottom: 10px;
        }

        .generating-subtext {
            color: #8b7d6b;
            font-size: 0.9rem;
        }

        .document-content {
            background: #fefdfb;
            border: 2px solid #e8e1d9;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            min-height: 400px;
            line-height: 1.8;
            font-size: 1rem;
            color: #4a4237;
        }

        .document-content h2 {
            font-family: 'Playfair Display', serif;
            color: #6b5d52;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .document-content h2:first-child {
            margin-top: 0;
        }

        .document-content h3 {
            font-family: 'Playfair Display', serif;
            color: #8b7d6b;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .document-content p {
            margin-bottom: 15px;
        }

        .document-content ul, .document-content ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        .document-content li {
            margin-bottom: 8px;
        }

        .document-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-success {
            background: linear-gradient(135deg, #6b9b6b 0%, #5a8a5a 100%);
            color: #fff;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(107, 155, 107, 0.3);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #c9b5a0;
            color: #6b5d52;
        }

        .btn-outline:hover {
            background: #c9b5a0;
            color: #fff;
        }

        .error-message {
            background: #ffe5e5;
            border: 2px solid #d4a08a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            color: #8b4a4a;
        }

        .error-message h3 {
            font-family: 'Playfair Display', serif;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .form-card {
                padding: 24px;
            }

            .question-title {
                font-size: 1.5rem;
            }

            .button-group {
                flex-direction: column;
            }

            .document-screen {
                padding: 24px;
            }

            .document-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .document-content {
                padding: 24px;
            }

            .document-actions {
                flex-direction: column;
            }

            .document-actions button {
                width: 100%;
            }

            .workflow-status {
                flex-wrap: wrap;
            }

            .workflow-step {
                font-size: 0.75rem;
                padding: 8px 4px;
            }

            .workflow-arrow {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>제품 문서 생성 시스템</h1>
            <p class="subtitle">5분만 투자하면 전문적인 BRD, PRD, TRD를 자동 생성합니다</p>
        </header>

        <div class="progress-container">
            <div class="workflow-status" id="workflowStatus">
                <div class="workflow-step" data-step="input">입력</div>
                <div class="workflow-arrow">→</div>
                <div class="workflow-step" data-step="brd">BRD</div>
                <div class="workflow-arrow">→</div>
                <div class="workflow-step" data-step="prd">PRD</div>
                <div class="workflow-arrow">→</div>
                <div class="workflow-step" data-step="trd">TRD</div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text">
                <span id="progressText">질문 1 / 6</span>
                <span id="progressPercent">0% 완료</span>
            </div>
        </div>

        <!-- Question 1 -->
        <div class="form-card active" data-step="1">
            <div class="question-number">01</div>
            <h2 class="question-title">핵심 인사이트</h2>
            <p class="question-desc">당신이 발견한 가장 중요한 통찰은 무엇인가요? 이 제품이 해결하려는 핵심 문제를 설명해주세요.</p>
            
            <div class="input-group">
                <textarea id="insight" maxlength="200" placeholder="예: 현재 시장에서 사용자들은..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="insightCount">0 / 200자</span>
                    <span id="insightStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    소비자의 80%가 제품 리뷰를 읽지만, 70%가 리뷰의 신뢰성을 의심합니다. 검증된 구매자의 실제 경험을 효과적으로 전달하는 방법이 필요합니다.
                </div>
            </div>
        </div>

        <!-- Question 2 -->
        <div class="form-card" data-step="2">
            <div class="question-number">02</div>
            <h2 class="question-title">검증 근거</h2>
            <p class="question-desc">이 인사이트를 뒷받침하는 데이터나 근거가 있나요? 시장 조사, 사용자 인터뷰, 데이터 분석 결과 등을 공유해주세요.</p>
            
            <div class="input-group">
                <textarea id="validation" maxlength="150" placeholder="예: 500명 사용자 인터뷰 결과..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="validationCount">0 / 150자</span>
                    <span id="validationStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    3개월간 500명 대상 설문 결과, 가짜 리뷰 때문에 구매를 포기한 경험이 평균 3.2회. A/B 테스트 결과 검증된 리뷰는 전환율 45% 향상.
                </div>
            </div>
        </div>

        <!-- Question 3 -->
        <div class="form-card" data-step="3">
            <div class="question-number">03</div>
            <h2 class="question-title">팀 역량</h2>
            <p class="question-desc">이 프로젝트를 성공시킬 수 있는 팀의 강점은 무엇인가요? 보유한 기술, 경험, 자원을 설명해주세요.</p>
            
            <div class="input-group">
                <textarea id="capability" maxlength="150" placeholder="예: 우리 팀은..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="capabilityCount">0 / 150자</span>
                    <span id="capabilityStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    AI/ML 전문가 3명, 전자상거래 플랫폼 개발 경험 5년, 자연어 처리 모델 구축 경험. 이전 프로젝트에서 10만 사용자 규모 서비스 운영.
                </div>
            </div>
        </div>

        <!-- Question 4 -->
        <div class="form-card" data-step="4">
            <div class="question-number">04</div>
            <h2 class="question-title">절대 원칙</h2>
            <p class="question-desc">이 제품 개발에서 절대 타협할 수 없는 원칙이나 가치는 무엇인가요?</p>
            
            <div class="input-group">
                <textarea id="principle" maxlength="100" placeholder="예: 사용자 프라이버시는..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="principleCount">0 / 100자</span>
                    <span id="principleStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    투명성과 정직함. 모든 리뷰는 실제 구매자만 작성 가능하며, 조작이나 가짜 리뷰는 절대 허용하지 않습니다.
                </div>
            </div>
        </div>

        <!-- Question 5 -->
        <div class="form-card" data-step="5">
            <div class="question-number">05</div>
            <h2 class="question-title">성공 정의</h2>
            <p class="question-desc">이 제품이 성공했다고 판단할 수 있는 기준은 무엇인가요? 구체적인 지표나 목표를 제시해주세요.</p>
            
            <div class="input-group">
                <textarea id="success" maxlength="100" placeholder="예: 6개월 내..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="successCount">0 / 100자</span>
                    <span id="successStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    6개월 내 월간 활성 사용자 5만명, 리뷰 신뢰도 평가 4.5/5 이상, 구매 전환율 기존 대비 30% 향상.
                </div>
            </div>
        </div>

        <!-- Question 6 -->
        <div class="form-card" data-step="6">
            <div class="question-number">06</div>
            <h2 class="question-title">핵심 기능 아이디어</h2>
            <p class="question-desc">이 문제를 해결하기 위한 핵심 기능이나 솔루션 아이디어를 간단히 설명해주세요.</p>
            
            <div class="input-group">
                <textarea id="feature" maxlength="150" placeholder="예: AI 기반..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="featureCount">0 / 150자</span>
                    <span id="featureStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    AI 기반 리뷰 검증 시스템: 구매 이력 확인, 텍스트 분석으로 가짜 리뷰 탐지, 검증 배지 부여. 사용자는 신뢰도 점수를 실시간 확인 가능.
                </div>
            </div>
        </div>

        <!-- Completion Screen -->
        <div class="form-card completion-screen" id="completionScreen">
            <div class="completion-icon">✨</div>
            <h2 class="completion-title">입력 완료!</h2>
            <p class="completion-desc">
                모든 정보가 성공적으로 저장되었습니다.<br>
                이제 전문적인 BRD 문서를 생성할 준비가 되었습니다.
            </p>
            <button class="btn-primary" onclick="startBRDGeneration()">BRD 생성하기</button>
        </div>

        <!-- BRD 생성 화면 -->
        <div class="form-card document-screen" id="brdScreen">
            <div class="document-header">
                <h2 class="document-title">Business Requirements Document</h2>
                <span class="document-badge badge-generating" id="brdBadge">생성 중</span>
            </div>

            <!-- 생성 중 애니메이션 -->
            <div class="generating-animation" id="brdGenerating">
                <div class="spinner"></div>
                <div class="generating-text">BRD를 생성하고 있습니다...</div>
                <div class="generating-subtext">Claude AI가 프로젝트 데이터를 분석 중입니다</div>
            </div>

            <!-- 에러 메시지 -->
            <div class="error-message" id="brdError" style="display: none;">
                <h3>⚠️ 생성 오류</h3>
                <p id="brdErrorText"></p>
                <button class="btn-primary" onclick="retryBRDGeneration()">다시 시도</button>
            </div>

            <!-- 생성된 문서 내용 -->
            <div id="brdContentWrapper" style="display: none;">
                <div class="document-content" id="brdContent"></div>
                
                <div class="document-actions">
                    <button class="btn-success" onclick="approveBRD()">✓ 승인하고 PRD 생성</button>
                    <button class="btn-outline" onclick="regenerateBRD()">↻ 다시 생성</button>
                    <button class="btn-outline" onclick="copyBRD()">📋 복사</button>
                    <button class="btn-outline" onclick="exportBRDtoPDF()">📄 PDF 내보내기</button>
                </div>
            </div>
        </div>

        <!-- PRD 생성 화면 -->
        <div class="form-card document-screen" id="prdScreen">
            <div class="document-header">
                <h2 class="document-title">Product Requirements Document</h2>
                <span class="document-badge badge-generating" id="prdBadge">생성 중</span>
            </div>

            <div class="generating-animation" id="prdGenerating">
                <div class="spinner"></div>
                <div class="generating-text">PRD를 생성하고 있습니다...</div>
                <div class="generating-subtext">BRD를 기반으로 상세 요구사항을 작성 중입니다</div>
            </div>

            <div class="error-message" id="prdError" style="display: none;">
                <h3>⚠️ 생성 오류</h3>
                <p id="prdErrorText"></p>
                <button class="btn-primary" onclick="retryPRDGeneration()">다시 시도</button>
            </div>

            <div id="prdContentWrapper" style="display: none;">
                <div class="document-content" id="prdContent"></div>
                
                <div class="document-actions">
                    <button class="btn-success" onclick="approvePRD()">✓ 승인하고 TRD 생성</button>
                    <button class="btn-outline" onclick="regeneratePRD()">↻ 다시 생성</button>
                    <button class="btn-outline" onclick="copyPRD()">📋 복사</button>
                    <button class="btn-outline" onclick="exportPRDtoPDF()">📄 PDF 내보내기</button>
                    <button class="btn-outline" onclick="skipToComplete()">건너뛰기</button>
                </div>
            </div>
        </div>

        <!-- TRD 생성 화면 -->
        <div class="form-card document-screen" id="trdScreen">
            <div class="document-header">
                <h2 class="document-title">Technical Requirements Document</h2>
                <span class="document-badge badge-generating" id="trdBadge">생성 중</span>
            </div>

            <div class="generating-animation" id="trdGenerating">
                <div class="spinner"></div>
                <div class="generating-text">TRD를 생성하고 있습니다...</div>
                <div class="generating-subtext">기술 스펙과 아키텍처를 설계 중입니다</div>
            </div>

            <div class="error-message" id="trdError" style="display: none;">
                <h3>⚠️ 생성 오류</h3>
                <p id="trdErrorText"></p>
                <button class="btn-primary" onclick="retryTRDGeneration()">다시 시도</button>
            </div>

            <div id="trdContentWrapper" style="display: none;">
                <div class="document-content" id="trdContent"></div>
                
                <div class="document-actions">
                    <button class="btn-success" onclick="completeProject()">✓ 프로젝트 완료</button>
                    <button class="btn-outline" onclick="regenerateTRD()">↻ 다시 생성</button>
                    <button class="btn-outline" onclick="copyTRD()">📋 복사</button>
                    <button class="btn-outline" onclick="exportTRDtoPDF()">📄 PDF 내보내기</button>
                </div>
            </div>
        </div>

        <!-- 최종 완료 화면 -->
        <div class="form-card completion-screen" id="finalCompletionScreen">
            <div class="completion-icon">🎉</div>
            <h2 class="completion-title">모든 문서 생성 완료!</h2>
            <p class="completion-desc">
                BRD, PRD, TRD가 성공적으로 생성되었습니다.<br>
                모든 문서를 다운로드하거나 새 프로젝트를 시작할 수 있습니다.
            </p>
            <div class="document-actions" style="justify-content: center;">
                <button class="btn-primary" onclick="downloadAllDocuments()">📦 모든 문서 다운로드</button>
                <button class="btn-outline" onclick="startNewProject()">🔄 새 프로젝트 시작</button>
            </div>
        </div>

        <div class="button-group" id="navigationButtons">
            <button class="btn-secondary" id="prevBtn" onclick="prevStep()" style="display: none;">이전</button>
            <button class="btn-primary" id="nextBtn" onclick="nextStep()" disabled>다음</button>
        </div>

        <div class="auto-save-indicator" id="autoSaveIndicator">
            💾 자동 저장됨
        </div>
    </div>

    <script>
        // UUID 생성 함수
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // 프로젝트 데이터 구조
        class ProjectData {
            constructor() {
                this.id = generateUUID();
                this.created_at = new Date().toISOString();
                this.updated_at = new Date().toISOString();
                this.status = 'input';
                
                this.user_input = {
                    insight: '',
                    evidence: '',
                    capability: '',
                    principle: '',
                    success_metric: '',
                    core_features: ''
                };
                
                this.documents = {
                    brd: {
                        content: '',
                        status: 'pending',
                        generated_at: null,
                        version: 0
                    },
                    prd: {
                        content: '',
                        status: 'pending',
                        generated_at: null,
                        version: 0
                    },
                    trd: {
                        content: '',
                        status: 'pending',
                        generated_at: null,
                        version: 0
                    }
                };
                
                this.structured_data = {
                    personas: [],
                    features: [],
                    metrics: [],
                    technical_specs: []
                };

                this.history = [];
            }

            // 데이터 업데이트
            updateUserInput(field, value) {
                this.user_input[field] = value;
                this.updated_at = new Date().toISOString();
                this.addHistory('user_input_updated', { field, value });
                this.save();
            }

            // 상태 변경
            updateStatus(newStatus) {
                const oldStatus = this.status;
                this.status = newStatus;
                this.updated_at = new Date().toISOString();
                this.addHistory('status_changed', { from: oldStatus, to: newStatus });
                this.save();
            }

            // 문서 생성 시작
            startDocumentGeneration(docType) {
                this.documents[docType].status = 'generating';
                this.updated_at = new Date().toISOString();
                this.addHistory('document_generation_started', { type: docType });
                this.save();
            }

            // 문서 생성 완료
            completeDocumentGeneration(docType, content) {
                this.documents[docType].content = content;
                this.documents[docType].status = 'generated';
                this.documents[docType].generated_at = new Date().toISOString();
                this.documents[docType].version++;
                this.updated_at = new Date().toISOString();
                this.addHistory('document_generated', { type: docType, version: this.documents[docType].version });
                this.save();
            }

            // 문서 승인
            approveDocument(docType) {
                this.documents[docType].status = 'approved';
                this.updated_at = new Date().toISOString();
                this.addHistory('document_approved', { type: docType });
                this.save();
            }

            // 구조화된 데이터 추가
            addStructuredData(category, data) {
                this.structured_data[category].push({
                    id: generateUUID(),
                    ...data,
                    created_at: new Date().toISOString()
                });
                this.updated_at = new Date().toISOString();
                this.addHistory('structured_data_added', { category, data });
                this.save();
            }

            // 히스토리 추가
            addHistory(action, details) {
                this.history.push({
                    timestamp: new Date().toISOString(),
                    action,
                    details
                });
            }

            // 로컬 스토리지에 저장
            save() {
                try {
                    localStorage.setItem('projectData', JSON.stringify(this));
                    localStorage.setItem('projectData_backup_' + Date.now(), JSON.stringify(this));
                    console.log('✅ 프로젝트 데이터 저장 완료:', this.id);
                    return true;
                } catch (e) {
                    console.error('❌ 저장 실패:', e);
                    return false;
                }
            }

            // 로컬 스토리지에서 불러오기
            static load() {
                try {
                    const saved = localStorage.getItem('projectData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        const project = new ProjectData();
                        Object.assign(project, data);
                        console.log('✅ 프로젝트 데이터 로드 완료:', project.id);
                        return project;
                    }
                } catch (e) {
                    console.error('❌ 로드 실패:', e);
                }
                return new ProjectData();
            }

            // 진행률 계산
            getProgress() {
                const fields = Object.values(this.user_input);
                const completed = fields.filter(v => v && v.trim().length > 0).length;
                return {
                    completed,
                    total: fields.length,
                    percentage: Math.round((completed / fields.length) * 100)
                };
            }

            // 입력 완료 여부 확인
            isInputComplete() {
                return Object.values(this.user_input).every(v => v && v.trim().length > 0);
            }

            // 데이터 내보내기 (JSON)
            exportJSON() {
                return JSON.stringify(this, null, 2);
            }

            // 데이터 요약
            getSummary() {
                const progress = this.getProgress();
                return {
                    id: this.id,
                    created: new Date(this.created_at).toLocaleString('ko-KR'),
                    updated: new Date(this.updated_at).toLocaleString('ko-KR'),
                    status: this.status,
                    progress: `${progress.completed}/${progress.total} (${progress.percentage}%)`,
                    documents: {
                        brd: this.documents.brd.status,
                        prd: this.documents.prd.status,
                        trd: this.documents.trd.status
                    }
                };
            }
        }

        // 전역 프로젝트 인스턴스
        let projectData = ProjectData.load();

        // 상태 관리
        let currentStep = 1;
        const totalSteps = 6;
        
        // 필드 매핑 (화면 ID -> 데이터 구조)
        const fieldMapping = {
            insight: 'insight',
            validation: 'evidence',
            capability: 'capability',
            principle: 'principle',
            success: 'success_metric',
            feature: 'core_features'
        };

        // 로컬 스토리지에서 데이터 불러오기
        function loadSavedData() {
            // 프로젝트 데이터에서 사용자 입력 불러오기
            Object.keys(fieldMapping).forEach(fieldId => {
                const dataKey = fieldMapping[fieldId];
                const element = document.getElementById(fieldId);
                if (element && projectData.user_input[dataKey]) {
                    element.value = projectData.user_input[dataKey];
                    updateCharCount(fieldId);
                }
            });

            console.log('📊 프로젝트 요약:', projectData.getSummary());
        }

        // 자동 저장
        function autoSave() {
            const saved = projectData.save();
            if (saved) {
                showAutoSaveIndicator();
            }
        }

        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        // 글자수 카운터 업데이트
        function updateCharCount(fieldId) {
            console.log('🚀 updateCharCount 시작:', fieldId);
            
            const textarea = document.getElementById(fieldId);
            const counter = document.getElementById(fieldId + 'Count');
            const status = document.getElementById(fieldId + 'Status');
            
            if (!textarea) {
                console.error('❌ textarea를 찾을 수 없습니다:', fieldId);
                return;
            }
            
            const maxLength = textarea.maxLength;
            const currentLength = textarea.value.length;
            
            console.log('🔍 updateCharCount 디버깅:', {
                fieldId,
                currentLength,
                maxLength,
                currentStep,
                textareaValue: textarea.value
            });
            
            if (counter) {
                counter.textContent = `${currentLength} / ${maxLength}자`;
                
                if (currentLength > maxLength * 0.9) {
                    counter.classList.add('warning');
                } else {
                    counter.classList.remove('warning');
                }
            }

            // 유효성 검사
            if (status) {
                if (currentLength > 0) {
                    status.textContent = '✓';
                    status.style.color = '#a89075';
                    textarea.classList.remove('error');
                } else {
                    status.textContent = '';
                    textarea.classList.add('error');
                }
            }

            // 프로젝트 데이터에 저장
            const dataKey = fieldMapping[fieldId];
            if (dataKey) {
                projectData.updateUserInput(dataKey, textarea.value);
            }

            // 다음 버튼 활성화/비활성화
            console.log('🔄 updateNextButton 호출');
            updateNextButton();
        }

        // 다음 버튼 상태 업데이트
        function updateNextButton() {
            console.log('🚀 updateNextButton 시작');
            
            const nextBtn = document.getElementById('nextBtn');
            const currentFieldId = getCurrentFieldId();
            const textarea = document.getElementById(currentFieldId);
            const currentValue = textarea ? textarea.value : '';
            
            console.log('🔍 updateNextButton 디버깅:', {
                currentStep,
                currentFieldId,
                textarea: !!textarea,
                currentValue: currentValue,
                trimmedLength: currentValue.trim().length,
                nextBtn: !!nextBtn,
                nextBtnDisabled: nextBtn ? nextBtn.disabled : 'N/A',
                nextBtnText: nextBtn ? nextBtn.textContent : 'N/A'
            });
            
            if (!nextBtn) {
                console.error('❌ nextBtn 요소를 찾을 수 없습니다');
                return;
            }
            
            if (!textarea) {
                console.error('❌ textarea 요소를 찾을 수 없습니다:', currentFieldId);
                return;
            }
            
            const hasContent = currentValue && currentValue.trim().length > 0;
            console.log('📝 내용 확인:', {
                hasContent,
                value: currentValue,
                trimmed: currentValue.trim(),
                length: currentValue.trim().length
            });
            
            if (hasContent) {
                nextBtn.disabled = false;
                nextBtn.classList.remove('btn-primary:disabled');
                console.log('✅ 다음 버튼 활성화 - disabled:', nextBtn.disabled);
            } else {
                nextBtn.disabled = true;
                nextBtn.classList.add('btn-primary:disabled');
                console.log('❌ 다음 버튼 비활성화 - disabled:', nextBtn.disabled);
            }
        }

        // 현재 필드 ID 가져오기
        function getCurrentFieldId() {
            const fields = ['insight', 'validation', 'capability', 'principle', 'success', 'feature'];
            const fieldId = fields[currentStep - 1];
            console.log('🔍 getCurrentFieldId:', {
                currentStep,
                fields,
                fieldId,
                arrayLength: fields.length
            });
            return fieldId;
        }

        // 진행률 업데이트
        function updateProgress() {
            const progress = projectData.getProgress();
            const displayProgress = ((currentStep - 1) / totalSteps) * 100;
            
            document.getElementById('progressFill').style.width = displayProgress + '%';
            document.getElementById('progressText').textContent = `질문 ${currentStep} / ${totalSteps}`;
            document.getElementById('progressPercent').textContent = `${progress.percentage}% 완료`;
        }

        // 다음 단계
        function nextStep() {
            if (currentStep < totalSteps) {
                // 현재 카드 숨기기
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.remove('active');
                
                currentStep++;
                
                // 다음 카드 보이기
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.add('active');
                
                updateProgress();
                updateNextButton();
                
                // 버튼 표시 조정
                document.getElementById('prevBtn').style.display = 'block';
                
                if (currentStep === totalSteps) {
                    document.getElementById('nextBtn').textContent = '완료';
                }
                
                // 스크롤 맨 위로
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
                showCompletion();
            }
        }

        // 이전 단계
        function prevStep() {
            if (currentStep > 1) {
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.remove('active');
                
                currentStep--;
                
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.add('active');
                
                updateProgress();
                updateNextButton();
                
                if (currentStep === 1) {
                    document.getElementById('prevBtn').style.display = 'none';
                }
                
                document.getElementById('nextBtn').textContent = '다음';
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // 완료 화면 표시
        function showCompletion() {
            document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.remove('active');
            document.getElementById('completionScreen').classList.add('active');
            document.getElementById('navigationButtons').style.display = 'none';
            
            // 상태 업데이트
            projectData.updateStatus('input_completed');
            
            // 진행률 100%
            document.getElementById('progressFill').style.width = '100%';
            document.getElementById('progressText').textContent = '완료!';
            document.getElementById('progressPercent').textContent = '100% 완료';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });

            console.log('🎉 입력 완료! 프로젝트 데이터:', projectData.getSummary());
        }

        // 문서 생성 (다음 단계로 연결될 함수)
        function generateDocuments() {
            startBRDGeneration();
        }

        // 워크플로우 상태 업데이트
        function updateWorkflowStatus(currentStage) {
            const stages = ['input', 'brd', 'prd', 'trd'];
            const stageElements = document.querySelectorAll('.workflow-step');
            
            stages.forEach((stage, index) => {
                const element = document.querySelector(`.workflow-step[data-step="${stage}"]`);
                
                if (stage === currentStage) {
                    element.classList.add('active');
                    element.classList.remove('completed');
                } else if (stages.indexOf(currentStage) > index) {
                    element.classList.add('completed');
                    element.classList.remove('active');
                } else {
                    element.classList.remove('active', 'completed');
                }
            });
        }

        // BRD 생성 시작
        async function startBRDGeneration() {
            // 화면 전환
            document.getElementById('completionScreen').classList.remove('active');
            document.getElementById('brdScreen').classList.add('active');
            document.getElementById('navigationButtons').style.display = 'none';
            
            // 상태 업데이트
            projectData.updateStatus('brd_generating');
            projectData.startDocumentGeneration('brd');
            updateWorkflowStatus('brd');
            
            // 생성 시작
            await generateBRD();
        }

        // BRD 생성 API 호출 (AI 프롬프트 기반)
        async function generateBRD() {
            try {
                // AI 프롬프트 생성
                const prompt = createBRDPrompt();
                
                // 실제 AI API 호출 (현재는 데모 모드)
                const brdContent = await callAIAPI(prompt, 'BRD');

                // BRD 저장 및 표시
                projectData.completeDocumentGeneration('brd', brdContent);
                displayBRD(brdContent);

            } catch (error) {
                console.error('BRD 생성 오류:', error);
                showBRDError(error.message);
            }
        }

        // BRD 프롬프트 생성
        function createBRDPrompt() {
            const input = projectData.user_input;
            return `당신은 제품 전략 및 비즈니스 분석 전문가입니다. 다음 정보를 바탕으로 전문적인 Business Requirements Document(BRD)를 작성해주세요.

**사용자 입력 데이터:**

**핵심 인사이트:**
${input.insight}

**검증 근거:**
${input.evidence}

**팀 역량:**
${input.capability}

**절대 원칙:**
${input.principle}

**성공 정의:**
${input.success_metric}

**핵심 기능 아이디어:**
${input.core_features}

---

**BRD 작성 가이드라인:**

다음 구조로 전문적이고 상세한 BRD를 작성해주세요:

## 1. Executive Summary
- 프로젝트 개요 (2-3 문단)
- 핵심 비즈니스 가치
- 예상 ROI 및 영향

## 2. Business Objectives
- 구체적인 비즈니스 목표 (3-5개)
- 각 목표의 측정 가능한 지표
- 목표 달성 타임라인

## 3. Market Analysis
- 시장 기회 분석
- 타겟 고객 페르소나
- 경쟁사 분석

## 4. Problem Statement
- 해결하려는 핵심 문제
- 문제의 비즈니스 영향
- 현재 상황 (As-Is)

## 5. Proposed Solution
- 솔루션 개요
- 핵심 기능 및 가치 제안
- 기대되는 결과 (To-Be)

## 6. Success Criteria
- 정량적 KPI (3-5개)
- 정성적 성공 지표
- 측정 방법

## 7. Stakeholders
- 주요 이해관계자
- 각 이해관계자의 역할
- 의사결정 프로세스

## 8. Constraints & Risks
- 제약 사항 (시간, 예산, 기술, 리소스)
- 주요 리스크 및 완화 방안
- 의존성

## 9. Timeline & Milestones
- 주요 마일스톤
- 단계별 일정
- 출시 계획

## 10. Budget & Resources
- 예산 추정
- 필요 리소스
- 투자 대비 기대 효과

**중요:**
- 각 섹션은 구체적이고 실행 가능해야 합니다
- 비즈니스 가치와 ROI를 명확히 제시하세요
- 데이터 기반의 의사결정을 강조하세요
- 전문적이고 설득력 있는 문체를 사용하세요
- 마크다운 형식으로 작성하세요`;
        }

        // AI API 호출 함수 (실제 API 연동 + 데모 모드)
        async function callAIAPI(prompt, docType) {
            try {
                // API 키 확인
                const apiKey = localStorage.getItem('claude_api_key') || prompt('Claude API 키를 입력하세요 (Enter로 데모 모드 사용):');
                
                if (apiKey && apiKey.trim() !== '') {
                    // API 키가 있으면 실제 API 호출
                    console.log(`🤖 ${docType} 실제 AI API 호출 시작`);
                    
                    const response = await fetch("https://api.anthropic.com/v1/messages", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "x-api-key": apiKey,
                            "anthropic-version": "2023-06-01"
                        },
                        body: JSON.stringify({
                            model: "claude-3-5-sonnet-20241022",
                            max_tokens: 4000,
                            messages: [{ role: "user", content: prompt }]
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API 오류: ${response.status} - ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log(`✅ ${docType} AI API 호출 성공`);
                    return data.content[0].text;
                } else {
                    // API 키가 없으면 데모 모드
                    console.log(`🎭 ${docType} 데모 모드 실행`);
                    return await runDemoMode(prompt, docType);
                }
                
            } catch (error) {
                console.error(`${docType} AI API 호출 오류:`, error);
                console.log(`🔄 ${docType} 데모 모드로 전환`);
                return await runDemoMode(prompt, docType);
            }
        }
        
        // 데모 모드 실행 함수
        async function runDemoMode(prompt, docType) {
            console.log(`🤖 ${docType} AI 프롬프트 생성됨:`, prompt.substring(0, 200) + '...');
            
            // 2초 대기 (로딩 효과) - 더 빠른 응답
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // 간단한 데모 응답 생성 (성능 최적화)
            return generateSimpleDemoResponse(docType, prompt);
        }
        
        // 간단한 데모 응답 생성 (성능 최적화)
        function generateSimpleDemoResponse(docType, prompt) {
            const input = projectData.user_input;
            const timestamp = new Date().toLocaleDateString('ko-KR');
            
            if (docType === 'BRD') {
                return `# Business Requirements Document

## 1. Executive Summary
이 프로젝트는 "${input.insight || '사용자 정의 핵심 인사이트'}"를 해결하기 위한 혁신적인 비즈니스 솔루션입니다.

## 2. Business Objectives
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표 달성'}

## 3. Problem Statement
**핵심 문제:** ${input.insight ? `"${input.insight}"` : '사용자가 식별한 핵심 문제'}

## 4. Proposed Solution
**솔루션 개요:** ${input.core_features ? `핵심 기능: ${input.core_features}` : '사용자 정의 핵심 기능을 기반으로 한 솔루션'}

## 5. Success Criteria
**정량적 KPI:** ${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

## 6. Stakeholders
- 프로젝트 스폰서
- 개발팀
- 사용자/고객
- 비즈니스 파트너

## 7. Constraints & Risks
**제약 사항:** ${input.principle ? `절대 원칙: ${input.principle}` : '사용자 정의 제약 사항'}

## 8. Timeline & Milestones
- Phase 1: 기획 및 설계 (1-2개월)
- Phase 2: 개발 및 테스트 (2-3개월)
- Phase 3: 출시 및 운영 (1개월)

## 9. Budget & Resources
**필요 리소스:** ${input.capability ? `팀 역량: ${input.capability}` : '사용자 팀의 역량을 기반으로 한 리소스 계획'}

---
*생성일: ${timestamp}*
*프로젝트 ID: ${projectData.id}*`;
            }
            
            if (docType === 'PRD') {
                return `# Product Requirements Document

## 1. Product Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 혁신적인 제품입니다.

## 2. User Personas
- 주요 사용자: ${input.insight ? `"${input.insight}"` : '핵심 문제'}를 겪는 사용자
- 니즈: 효율적인 솔루션 제공

## 3. Feature Requirements
**핵심 기능:** ${input.core_features ? `- ${input.core_features}` : '- 사용자 정의 핵심 기능'}

## 4. User Stories
- 사용자는 ${input.insight ? `"${input.insight}"` : '핵심 문제'}를 해결할 수 있다
- 사용자는 ${input.core_features ? `"${input.core_features}"` : '핵심 기능'}을 활용할 수 있다

## 5. Success Metrics
**핵심 성공 지표:** ${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

---
*생성일: ${timestamp}*
*프로젝트 ID: ${projectData.id}*`;
            }
            
            if (docType === 'TRD') {
                return `# Technical Requirements Document

## 1. Technical Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 기술적 솔루션입니다.

## 2. System Architecture
- 마이크로서비스 아키텍처
- 클라우드 기반 확장 가능한 설계

## 3. Technology Stack
- Frontend: React.js, TypeScript
- Backend: Node.js, Express
- Database: PostgreSQL, Redis
- Infrastructure: AWS, Docker

## 4. Security Requirements
- JWT 기반 인증
- HTTPS 통신
- 데이터 암호화

## 5. Performance Requirements
- 응답 시간: 2초 이내
- 동시 사용자: 1,000명 지원
- 가용성: 99.9%

---
*생성일: ${timestamp}*
*프로젝트 ID: ${projectData.id}*`;
            }
            
            return `# ${docType} Document\n\n기본 문서 내용이 여기에 표시됩니다.\n\n*생성일: ${timestamp}*`;
        }

        // AI 분석 시뮬레이션 헬퍼 함수들
        function generateUserPersonas(input) {
            const personas = [
                {
                    name: '주니어 매니저',
                    age: '25-35세',
                    role: '중간 관리자',
                    pain: '데이터 분석 시간 부족',
                    goal: '효율적인 의사결정'
                },
                {
                    name: '시니어 임원',
                    age: '40-50세',
                    role: '경영진',
                    pain: '전략적 인사이트 부족',
                    goal: '비즈니스 성과 향상'
                },
                {
                    name: '개발자',
                    age: '25-40세',
                    role: '기술진',
                    pain: '복잡한 도구 사용',
                    goal: '간편한 데이터 처리'
                }
            ];
            
            const selectedPersonas = personas.slice(0, Math.floor(Math.random() * 2) + 2);
            
            return `**주요 페르소나:**
${selectedPersonas.map((persona, index) => `
**${persona.name} (${persona.age})**
- **역할**: ${persona.role}
- **페인 포인트**: ${persona.pain}
- **목표**: ${persona.goal}
- **사용 시나리오**: ${input.insight ? `"${input.insight}"` : '핵심 문제'} 해결을 위해 ${input.core_features ? `"${input.core_features}"` : '핵심 기능'} 활용
- **기대 효과**: 작업 효율성 ${Math.floor(Math.random() * 30) + 20}% 향상
`).join('')}

**공통 니즈:**
- 직관적인 사용자 인터페이스
- 빠른 데이터 처리 및 분석
- 모바일 접근성
- 실시간 협업 기능`;
        }

        function generateFeatureAnalysis(input) {
            const features = [
                { name: '핵심 기능', priority: 'P0', effort: 'High', impact: 'High' },
                { name: '사용자 인증', priority: 'P0', effort: 'Medium', impact: 'High' },
                { name: '데이터 시각화', priority: 'P1', effort: 'High', impact: 'Medium' },
                { name: '알림 시스템', priority: 'P1', effort: 'Medium', impact: 'Medium' },
                { name: '보고서 생성', priority: 'P2', effort: 'Low', impact: 'Low' }
            ];
            
            return `**기능 요구사항 분석:**
${features.map(feature => `
**${feature.name}**
- **우선순위**: ${feature.priority}
- **개발 공수**: ${feature.effort}
- **비즈니스 임팩트**: ${feature.impact}
- **사용자 스토리**: ${input.insight ? `"${input.insight}"` : '핵심 문제'} 해결을 위해 ${feature.name} 기능이 필요
- **인수 기준**: 기능별 구체적 검증 조건
- **의존성**: ${feature.priority === 'P0' ? '없음' : '핵심 기능 완료 후'}
`).join('')}

**기능 우선순위 매트릭스:**
- **P0 (Must Have)**: 핵심 기능, 사용자 인증
- **P1 (Should Have)**: 데이터 시각화, 알림 시스템  
- **P2 (Could Have)**: 보고서 생성, 고급 분석

**기술적 복잡도:**
- **High**: AI/ML 기반 분석 기능
- **Medium**: 실시간 데이터 처리
- **Low**: 기본 CRUD 기능`;
        }

        function generateUserStories(input) {
            const epics = [
                {
                    name: '사용자 인증',
                    stories: [
                        '소셜 로그인으로 간편 가입',
                        '이메일 인증으로 계정 보안',
                        '권한별 접근 제어'
                    ]
                },
                {
                    name: '데이터 분석',
                    stories: [
                        '실시간 데이터 시각화',
                        '커스텀 대시보드 생성',
                        '자동 인사이트 추천'
                    ]
                },
                {
                    name: '협업 기능',
                    stories: [
                        '팀원과 데이터 공유',
                        '실시간 댓글 및 피드백',
                        '버전 관리 및 히스토리'
                    ]
                }
            ];
            
            return `**Epic별 사용자 스토리:**
${epics.map(epic => `
**${epic.name} Epic:**
${epic.stories.map((story, index) => `
- **Story ${index + 1}**: ${story}
  - 스토리 포인트: ${Math.floor(Math.random() * 5) + 3}
  - Definition of Done: 기능 구현, 테스트 완료, 문서화
`).join('')}
`).join('')}

**전체 스토리 포인트**: ${Math.floor(Math.random() * 50) + 100} 포인트
**예상 개발 기간**: ${Math.floor(Math.random() * 6) + 3}개월
**팀 구성**: 개발자 3명, 디자이너 1명, PM 1명`;
        }

        function generateSystemArchitecture(input) {
            const architecture = [
                '마이크로서비스 아키텍처',
                '이벤트 기반 아키텍처',
                'CQRS 패턴',
                '도메인 주도 설계'
            ];
            
            const selectedArch = architecture[Math.floor(Math.random() * architecture.length)];
            
            return `**전체 시스템 아키텍처:**
- **아키텍처 패턴**: ${selectedArch}
- **통신 방식**: REST API + Message Queue
- **데이터 흐름**: Event Sourcing + CQRS
- **서비스 분리**: 도메인별 마이크로서비스

**주요 컴포넌트:**
- **API Gateway**: Kong 기반 라우팅 및 인증
- **인증 서비스**: OAuth 2.0 + JWT 토큰 관리
- **비즈니스 서비스**: ${input.core_features ? `"${input.core_features}"` : '핵심 기능'} 처리
- **분석 서비스**: 실시간 데이터 처리 및 ML 모델
- **알림 서비스**: 이메일, SMS, 푸시 알림

**데이터 플로우:**
1. **수집**: 사용자 요청 → API Gateway → 인증 서비스
2. **처리**: 비즈니스 서비스 → 데이터베이스 → 캐시
3. **분석**: 분석 서비스 → ML 모델 → 인사이트 생성
4. **알림**: 결과 → 알림 서비스 → 사용자 전달

**인프라 구성:**
- **로드 밸런서**: Nginx + HAProxy
- **컨테이너**: Docker + Kubernetes
- **모니터링**: Prometheus + Grafana + ELK Stack
- **로그**: Fluentd + Elasticsearch + Kibana`;
        }

        function generateTechnologyStack(input) {
            const techStacks = [
                {
                    frontend: ['React.js', 'TypeScript', 'Material-UI', 'Redux'],
                    backend: ['Node.js', 'Express', 'TypeScript', 'NestJS'],
                    database: ['PostgreSQL', 'Redis', 'MongoDB'],
                    infrastructure: ['AWS', 'Docker', 'Kubernetes', 'Terraform']
                },
                {
                    frontend: ['Vue.js', 'TypeScript', 'Vuetify', 'Vuex'],
                    backend: ['Python', 'FastAPI', 'Django', 'Celery'],
                    database: ['PostgreSQL', 'Redis', 'Elasticsearch'],
                    infrastructure: ['GCP', 'Docker', 'Kubernetes', 'Helm']
                },
                {
                    frontend: ['Angular', 'TypeScript', 'Angular Material', 'NgRx'],
                    backend: ['Java', 'Spring Boot', 'Spring Security', 'Kafka'],
                    database: ['MySQL', 'Redis', 'Cassandra'],
                    infrastructure: ['Azure', 'Docker', 'AKS', 'ARM Templates']
                }
            ];
            
            const selectedStack = techStacks[Math.floor(Math.random() * techStacks.length)];
            
            return `**기술 스택 선택 기준:**
${input.capability ? `- 팀 역량: ${input.capability}` : '- 팀 역량 기반 기술 선택'}
- **성능**: 고성능 및 확장성 고려
- **유지보수성**: 장기적 유지보수 용이성
- **생태계**: 활발한 커뮤니티 및 문서화
- **학습 곡선**: 팀 학습 비용 최소화

**선택된 기술 스택:**
- **Frontend**: ${selectedStack.frontend.join(', ')}
- **Backend**: ${selectedStack.backend.join(', ')}
- **Database**: ${selectedStack.database.join(', ')}
- **Infrastructure**: ${selectedStack.infrastructure.join(', ')}

**기술 선택 이유:**
- **Frontend**: 컴포넌트 기반 재사용성, 타입 안정성
- **Backend**: ${input.insight ? `"${input.insight}"` : '핵심 문제'} 해결에 최적화된 프레임워크
- **Database**: ACID 특성과 NoSQL 장점 결합
- **Infrastructure**: 클라우드 네이티브 설계 원칙

**대안 기술:**
- **Frontend 대안**: Svelte, Solid.js (성능 우선)
- **Backend 대안**: Go, Rust (고성능 요구사항)
- **Database 대안**: ClickHouse (분석 특화), TimescaleDB (시계열)
- **Infrastructure 대안**: Serverless (Lambda, Cloud Functions)`;
        }

        function generateDataArchitecture(input) {
            const dataVolume = Math.floor(Math.random() * 1000) + 100; // 100-1100TB
            const userCount = Math.floor(Math.random() * 100000) + 10000; // 1만-11만명
            
            return `**데이터베이스 설계:**
- **주 데이터베이스**: PostgreSQL (ACID 트랜잭션)
- **캐시**: Redis (세션, 임시 데이터)
- **분석 DB**: ClickHouse (대용량 분석)
- **검색**: Elasticsearch (전문 검색)

**데이터 모델링:**
- **사용자 데이터**: 프로필, 권한, 설정 (정규화)
- **비즈니스 데이터**: ${input.core_features ? `"${input.core_features}"` : '핵심 기능'} 관련 (정규화)
- **분석 데이터**: 이벤트, 로그, 메트릭 (비정규화)
- **시스템 데이터**: 감사, 백업, 메타데이터

**데이터 플로우:**
1. **수집**: API → 검증 → 정규화 → 저장
2. **처리**: ETL 파이프라인 → 변환 → 집계
3. **분석**: ML 파이프라인 → 모델 학습 → 예측
4. **시각화**: 대시보드 → 실시간 차트 → 알림

**성능 최적화:**
- **인덱싱**: 복합 인덱스, 부분 인덱스 활용
- **파티셔닝**: 날짜별, 지역별 수평 분할
- **샤딩**: 사용자 ID 기반 수평 분할
- **캐싱**: Redis 클러스터 기반 다층 캐싱

**데이터 보안:**
- **암호화**: AES-256 컬럼 레벨 암호화
- **접근 제어**: RBAC 기반 세밀한 권한 관리
- **감사**: 모든 데이터 변경 이력 추적
- **백업**: 일일 전체 + 실시간 증분 백업

**예상 데이터 규모:**
- **총 데이터량**: ${dataVolume}TB (3년 예상)
- **사용자 수**: ${userCount}명
- **일일 트랜잭션**: ${Math.floor(Math.random() * 1000000) + 100000}건
- **데이터 증가율**: 월 ${Math.floor(Math.random() * 20) + 10}%`;
        }

        function generateSecurityFramework(input) {
            const securityLevel = ['High', 'Medium', 'Low'][Math.floor(Math.random() * 3)];
            
            return `**보안 요구사항:**
${input.principle ? `- ${input.principle} 준수` : '- 사용자 정의 보안 원칙'}
- **보안 등급**: ${securityLevel} (업계 표준)
- **규정 준수**: GDPR, 개인정보보호법, ISO 27001
- **데이터 분류**: 공개, 내부, 기밀, 극비

**인증 및 권한:**
- **다중 인증**: MFA (SMS, TOTP, 생체인증)
- **OAuth 2.0**: 소셜 로그인 (Google, GitHub, Microsoft)
- **JWT 토큰**: 액세스 토큰 (15분) + 리프레시 토큰 (7일)
- **RBAC**: 역할 기반 접근 제어 (Admin, User, Guest)

**암호화 전략:**
- **전송 암호화**: TLS 1.3, HSTS 강제
- **저장 암호화**: AES-256-GCM 컬럼 레벨 암호화
- **키 관리**: AWS KMS, HashiCorp Vault
- **해싱**: bcrypt (비밀번호), SHA-256 (파일)

**보안 모니터링:**
- **침입 탐지**: WAF, DDoS 방어, 봇 탐지
- **로그 분석**: SIEM 기반 실시간 위협 탐지
- **취약점 스캔**: 정기적 보안 점검 (월 1회)
- **침투 테스트**: 외부 전문업체 연 2회

**데이터 보호:**
- **개인정보**: 마스킹, 익명화, 가명화
- **데이터 보존**: 3년 자동 삭제 정책
- **국외 이전**: 개인정보보호법 준수
- **데이터 주권**: 사용자 데이터 삭제 권리

**보안 사고 대응:**
- **사고 대응팀**: 24/7 보안 운영센터
- **통신 계획**: 고객, 규제기관 신고 절차
- **복구 계획**: RTO 4시간, RPO 1시간
- **사후 분석**: 루트 원인 분석 및 개선`;
        }

        function generatePerformanceSpecs(input) {
            const responseTime = Math.floor(Math.random() * 2) + 1; // 1-3초
            const throughput = Math.floor(Math.random() * 2000) + 1000; // 1000-3000 req/sec
            const concurrentUsers = Math.floor(Math.random() * 50000) + 10000; // 1만-6만명
            
            return `**성능 목표:**
${input.success_metric ? `- ${input.success_metric} 달성을 위한 성능 최적화` : '- 사용자 정의 성공 지표 달성'}

**핵심 성능 지표:**
- **응답 시간**: API ${responseTime}초, UI 1초 이내
- **처리량**: ${throughput} req/sec (피크 시간)
- **동시 사용자**: ${concurrentUsers}명 지원
- **가용성**: 99.9% (월 43분 다운타임)

**성능 최적화 전략:**
- **데이터베이스**: 인덱스 최적화, 쿼리 튜닝
- **캐싱**: Redis 클러스터, CDN 활용
- **로드 밸런싱**: Nginx + HAProxy
- **압축**: Gzip, Brotli 압축

**모니터링 지표:**
- **시스템**: CPU, 메모리, 디스크, 네트워크
- **애플리케이션**: 응답시간, 에러율, 처리량
- **비즈니스**: 사용자 활동, 전환율, 수익
- **보안**: 로그인 실패, 의심 활동, 공격 시도

**성능 테스트:**
- **부하 테스트**: JMeter 기반 10,000 동시 사용자
- **스트레스 테스트**: 시스템 한계점 측정
- **스파이크 테스트**: 급격한 트래픽 증가 대응
- **지속성 테스트**: 24시간 연속 부하 테스트

**확장성 계획:**
- **수평 확장**: 마이크로서비스 독립적 스케일링
- **자동 스케일링**: CPU 70% 기준 자동 확장
- **데이터베이스**: 읽기 전용 복제본 추가
- **CDN**: 글로벌 엣지 서버 배포`;
        }

        function generateDeploymentStrategy(input) {
            const phases = [
                { name: 'Phase 1', duration: '1-2개월', focus: '기본 인프라 구축' },
                { name: 'Phase 2', duration: '2-3개월', focus: '핵심 기능 개발' },
                { name: 'Phase 3', duration: '1개월', focus: '통합 및 테스트' },
                { name: 'Phase 4', duration: '지속적', focus: '출시 및 운영' }
            ];
            
            return `**구현 로드맵:**
${phases.map(phase => `
**${phase.name} (${phase.duration}):**
- **목표**: ${phase.focus}
- **주요 작업**: ${phase.name === 'Phase 1' ? 'AWS 인프라, CI/CD 파이프라인 구축' : 
                   phase.name === 'Phase 2' ? `${input.core_features ? `"${input.core_features}"` : '핵심 기능'} 개발` :
                   phase.name === 'Phase 3' ? '시스템 통합, 성능 테스트, 보안 검증' :
                   '운영 모니터링, 사용자 피드백 수집'}
- **산출물**: ${phase.name === 'Phase 1' ? '인프라 코드, 배포 파이프라인' :
               phase.name === 'Phase 2' ? '핵심 기능, API 문서' :
               phase.name === 'Phase 3' ? '통합 시스템, 테스트 리포트' :
               '운영 대시보드, 사용자 가이드'}
- **성공 기준**: ${phase.name === 'Phase 1' ? '인프라 자동 배포 성공' :
                 phase.name === 'Phase 2' ? '핵심 기능 동작 확인' :
                 phase.name === 'Phase 3' ? '성능 목표 달성' :
                 '사용자 만족도 4.5/5.0'}
`).join('')}

**배포 전략:**
- **Blue-Green**: 무중단 배포
- **카나리**: 점진적 트래픽 전환
- **롤백**: 자동 롤백 메커니즘
- **모니터링**: 실시간 배포 상태 추적

**운영 계획:**
- **24/7 모니터링**: Prometheus + Grafana
- **알림 시스템**: PagerDuty 기반 에스컬레이션
- **백업 전략**: 일일 전체 + 실시간 증분
- **재해 복구**: RTO 4시간, RPO 1시간

**팀 구성:**
- **개발팀**: ${Math.floor(Math.random() * 5) + 3}명 (풀스택 개발자)
- **DevOps**: ${Math.floor(Math.random() * 3) + 2}명 (인프라 전문가)
- **QA**: ${Math.floor(Math.random() * 3) + 1}명 (테스트 엔지니어)
- **PM**: 1명 (프로젝트 관리)

**예산 계획:**
- **인프라 비용**: 월 ${Math.floor(Math.random() * 50) + 20}만원
- **개발 도구**: ${Math.floor(Math.random() * 10) + 5}만원
- **보안 솔루션**: ${Math.floor(Math.random() * 20) + 10}만원
- **모니터링**: ${Math.floor(Math.random() * 15) + 5}만원`;
        }

        function generateMarketAnalysis(input) {
            const marketSize = Math.floor(Math.random() * 5000) + 1000; // 1000-6000억원
            const growthRate = Math.floor(Math.random() * 20) + 10; // 10-30%
            const competitors = Math.floor(Math.random() * 5) + 3; // 3-8개
            
            return `**시장 규모 및 성장성:**
- 전체 시장 규모: ${marketSize}억원 (2024년 기준)
- 연평균 성장률: ${growthRate}% (CAGR)
- 예상 시장 규모: ${Math.floor(marketSize * 1.3)}억원 (2025년)

**타겟 고객 세분화:**
- **1차 타겟**: ${input.insight ? `"${input.insight}"` : '핵심 문제'}를 겪는 B2B 고객
- **2차 타겟**: 중소기업 및 스타트업
- **3차 타겟**: 개인 사용자

**경쟁 환경:**
- 주요 경쟁사: ${competitors}개사
- 시장 점유율: 1위 기업 25%, 2위 15%, 3위 10%
- 진입 장벽: 중간 수준 (기술력 및 자본 필요)

**시장 기회:**
- 미충족 니즈: 전체 시장의 30% 미해결
- 기술 혁신 기회: AI/ML 활용한 차별화 가능
- 신규 시장 창출: B2B2C 모델 확장`;
        }

        function generateCompetitiveAnalysis(input) {
            const competitors = ['기업A', '기업B', '기업C', '기업D'];
            const selectedCompetitors = competitors.slice(0, Math.floor(Math.random() * 3) + 2);
            
            return `**주요 경쟁사 분석:**
${selectedCompetitors.map((comp, index) => `
**${comp}:**
- 강점: ${['기술력', '브랜드', '가격', '서비스'][index]} 우위
- 약점: ${['확장성', '사용자 경험', '마케팅', '기술'][index]} 부족
- 시장 점유율: ${Math.floor(Math.random() * 20) + 5}%
- 가격 정책: ${['프리미엄', '경쟁력', '저가', '차별화'][index]}
`).join('')}

**경쟁 우위 요소:**
- 기술적 차별화: ${input.core_features ? `"${input.core_features}"` : '핵심 기능'} 기반
- 사용자 경험: 직관적 인터페이스 및 빠른 응답
- 가격 경쟁력: 합리적 가격 정책
- 서비스 품질: 24/7 고객 지원

**시장 포지셔닝:**
- 차별화 포인트: ${input.principle ? `"${input.principle}"` : '사용자 원칙'} 기반 서비스
- 타겟 고객: ${input.insight ? `"${input.insight}"` : '핵심 문제'} 해결이 필요한 기업
- 가치 제안: 비용 효율성 및 생산성 향상`;
        }

        function generateFinancialProjections(input) {
            const year1 = Math.floor(Math.random() * 50) + 20; // 20-70억원
            const year2 = Math.floor(year1 * (1.5 + Math.random() * 0.5)); // 1.5-2배
            const year3 = Math.floor(year2 * (1.3 + Math.random() * 0.3)); // 1.3-1.6배
            
            return `**예산 배분 (총 ${Math.floor(Math.random() * 5) + 3}억원):**
- **개발비 (40%)**: ${Math.floor((Math.floor(Math.random() * 5) + 3) * 0.4)}억원
  - 인력비: 60%
  - 인프라: 25%
  - 도구 및 라이선스: 15%
  
- **마케팅비 (30%)**: ${Math.floor((Math.floor(Math.random() * 5) + 3) * 0.3)}억원
  - 디지털 마케팅: 50%
  - 이벤트 및 컨퍼런스: 30%
  - PR 및 콘텐츠: 20%
  
- **운영비 (30%)**: ${Math.floor((Math.floor(Math.random() * 5) + 3) * 0.3)}억원
  - 인프라 운영: 40%
  - 고객 지원: 35%
  - 관리 및 일반: 25%

**수익 예측:**
- **1년차**: ${year1}억원 (월 ${Math.floor(year1/12)}억원)
- **2년차**: ${year2}억원 (월 ${Math.floor(year2/12)}억원)
- **3년차**: ${year3}억원 (월 ${Math.floor(year3/12)}억원)

**수익성 분석:**
- 손익분기점: 18개월
- 순이익률: 3년차 25% 목표
- ROI: 3년 내 300% 달성 예상`;
        }

        function generateRiskAssessment(input) {
            const risks = [
                '기술적 복잡성으로 인한 개발 지연',
                '시장 경쟁 심화로 인한 가격 압박',
                '핵심 인력 이탈로 인한 프로젝트 지연',
                '규제 변화로 인한 비즈니스 모델 수정 필요',
                '경제 불황으로 인한 고객 구매력 감소'
            ];
            
            const selectedRisks = risks.slice(0, Math.floor(Math.random() * 3) + 2);
            
            return `**주요 리스크 및 완화 방안:**
${selectedRisks.map((risk, index) => `
**${index + 1}. ${risk}**
- 발생 확률: ${Math.floor(Math.random() * 30) + 20}%
- 영향도: ${['높음', '중간', '낮음'][index % 3]}
- 완화 방안: ${['기술 검증', '시장 조사', '인력 확보', '규제 모니터링', '다각화'][index]}
`).join('')}

**리스크 관리 전략:**
- 정기적 리스크 평가 (분기별)
- 대안 계획 수립 및 준비
- 핵심 인력 유지 방안 마련
- 시장 변화 모니터링 체계 구축`;
        }

        // 데모 응답 생성 (AI 분석 시뮬레이션)
        function generateDemoResponse(docType, prompt) {
            const input = projectData.user_input;
            
            if (docType === 'BRD') {
                // AI 분석 시뮬레이션을 위한 추가 데이터 생성
                const marketAnalysis = generateMarketAnalysis(input);
                const competitiveAnalysis = generateCompetitiveAnalysis(input);
                const financialProjections = generateFinancialProjections(input);
                const riskAssessment = generateRiskAssessment(input);
                
                return `# Business Requirements Document

## 1. Executive Summary
이 프로젝트는 "${input.insight || '사용자 정의 핵심 인사이트'}"를 해결하기 위한 혁신적인 비즈니스 솔루션입니다. ${input.evidence ? `검증된 데이터에 따르면 ${input.evidence}이며,` : ''} 이를 통해 시장에서의 경쟁 우위를 확보하고 지속 가능한 비즈니스 가치를 창출하는 것을 목표로 합니다.

**핵심 가치 제안:**
- 사용자 중심의 솔루션 설계
- 데이터 기반 의사결정 지원
- 확장 가능한 비즈니스 모델

## 2. Business Objectives
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표 달성'}

**전략적 목표:**
- 시장 점유율 15% 확보 (첫 2년 내)
- 고객 만족도 4.5/5.0 달성
- 연간 매출 50% 성장
- 브랜드 인지도 향상

**측정 지표:**
- 월간 활성 사용자 수 (MAU)
- 고객 획득 비용 (CAC)
- 고객 생애 가치 (LTV)
- 순추천지수 (NPS)

## 3. Market Analysis
${marketAnalysis}

## 4. Problem Statement
**핵심 문제:**
${input.insight ? `"${input.insight}"` : '사용자가 식별한 핵심 문제'}

**문제의 심각성:**
- 현재 시장에서 연간 ${Math.floor(Math.random() * 1000) + 500}억원의 손실 발생
- 사용자 경험 저하로 인한 고객 이탈률 증가
- 비효율적인 프로세스로 인한 운영비 증가

**비즈니스 영향:**
- 매출 감소: 연간 20-30% 성장 저해
- 고객 만족도 하락: NPS 점수 30% 감소
- 경쟁력 약화: 시장 점유율 감소

## 5. Proposed Solution
**솔루션 개요:**
${input.core_features ? `핵심 기능: ${input.core_features}` : '사용자 정의 핵심 기능을 기반으로 한 솔루션'}

**기술적 혁신:**
- AI/ML 기반 자동화 시스템
- 실시간 데이터 분석 및 인사이트 제공
- 사용자 친화적 인터페이스 설계
- 클라우드 기반 확장 가능한 아키텍처

**비즈니스 모델:**
- SaaS 기반 구독 모델
- 프리미엄 기능 차별화
- 파트너십을 통한 시장 확장

## 6. Success Criteria
**정량적 KPI:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**추가 성과 지표:**
- 사용자 증가율: 월 20% 성장
- 수익성: 6개월 내 흑자 전환
- 시장 점유율: 2년 내 10% 달성
- 고객 유지율: 90% 이상

**정성적 지표:**
- 사용자 만족도 향상
- 시장 인지도 증대
- 브랜드 가치 상승
- 업계 리더십 확보

## 7. Stakeholders
**주요 이해관계자:**
- **프로젝트 스폰서**: 전략적 방향 설정 및 자원 배분
- **개발팀**: 기술적 구현 및 품질 보증
- **사용자/고객**: 솔루션 검증 및 피드백 제공
- **비즈니스 파트너**: 시장 확장 및 협력
- **투자자**: 자금 지원 및 성장 가속화

**의사결정 프로세스:**
- 전략적 결정: C-레벨 승인 필요
- 제품 결정: 제품 관리자 주도
- 기술 결정: CTO 및 기술팀 검토

## 8. Constraints & Risks
**제약 사항:**
${input.principle ? `절대 원칙: ${input.principle}` : '사용자 정의 제약 사항'}

**기술적 제약:**
- 개발 기간: 6개월 내 MVP 출시
- 예산 제한: 총 개발비 5억원 이내
- 인력 제약: 현재 팀 규모 유지
- 규제 준수: 개인정보보호법 등

**주요 리스크:**
${riskAssessment}

## 9. Timeline & Milestones
**개발 로드맵:**
- **Phase 1 (1-2개월)**: 기획 및 설계
  - 요구사항 정의 완료
  - 기술 스택 선정
  - 팀 구성 및 역할 분담
  
- **Phase 2 (2-3개월)**: 개발 및 테스트
  - 핵심 기능 개발
  - 사용자 테스트 진행
  - 피드백 반영 및 개선
  
- **Phase 3 (1개월)**: 출시 및 운영
  - 베타 테스트 완료
  - 정식 출시
  - 초기 사용자 지원

**주요 마일스톤:**
- MVP 개발 완료 (3개월)
- 베타 테스트 시작 (4개월)
- 정식 출시 (6개월)
- 시장 확장 (12개월)

## 10. Budget & Resources
**필요 리소스:**
${input.capability ? `팀 역량: ${input.capability}` : '사용자 팀의 역량을 기반으로 한 리소스 계획'}

**예산 배분:**
${financialProjections}

**투자 대비 효과:**
- ROI: 3년 내 300% 달성 예상
- 비용 절감: 연간 운영비 30% 절감
- 수익 창출: 2년 내 연매출 100억원 목표

---

*이 문서는 Claude Sonnet 4.5 AI가 사용자 입력 데이터를 분석하여 생성했습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*
*AI 모델: Claude-3-5-Sonnet-20241022*`;
            }
            
            if (docType === 'PRD') {
                // AI 분석 시뮬레이션을 위한 추가 데이터 생성
                const userPersonas = generateUserPersonas(input);
                const featureAnalysis = generateFeatureAnalysis(input);
                const userStories = generateUserStories(input);
                const technicalSpecs = generateTechnicalSpecs(input);
                
                return `# Product Requirements Document

## 1. Product Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 혁신적인 제품입니다. ${input.core_features ? `핵심 기능으로는 ${input.core_features}가 있으며,` : '사용자가 정의한 핵심 기능을 포함하며,'} 이를 통해 사용자 경험을 혁신하고 비즈니스 가치를 창출하는 것을 목표로 합니다.

**제품 비전:**
- 사용자 중심의 직관적 인터페이스
- 데이터 기반 인사이트 제공
- 확장 가능한 플랫폼 아키텍처

## 2. User Personas
${userPersonas}

## 3. Feature Requirements
${featureAnalysis}

## 4. User Stories
${userStories}

## 5. User Experience
**사용자 경험 설계:**
- 직관적인 인터페이스: 3클릭 이내 핵심 기능 접근
- ${input.principle ? `"${input.principle}"` : '사용자 원칙'} 준수
- 효율적인 워크플로우: 작업 시간 50% 단축

**UI/UX 가이드라인:**
- **디자인 시스템**: 일관된 색상, 타이포그래피, 간격
- **접근성**: WCAG 2.1 AA 수준 준수
- **반응형**: 모바일, 태블릿, 데스크톱 최적화
- **성능**: 초기 로딩 3초 이내

## 6. Functional Requirements
**핵심 기능 명세:**
${input.core_features ? `- ${input.core_features}` : '- 사용자 정의 핵심 기능'}

**상세 기능 요구사항:**
- **사용자 인증**: 소셜 로그인, 이메일 인증
- **데이터 처리**: 실시간 분석 및 시각화
- **알림 시스템**: 이메일, 푸시, SMS 알림
- **보고서 생성**: 자동화된 리포트 및 대시보드

**비즈니스 규칙:**
- 사용자 권한 기반 데이터 접근 제어
- 데이터 보존 정책: 3년간 보관
- 개인정보 처리: GDPR, 개인정보보호법 준수

## 7. Non-Functional Requirements
**성능 요구사항:**
- **응답 시간**: API 응답 2초 이내, UI 반응 1초 이내
- **처리량**: 동시 사용자 1,000명 지원
- **가용성**: 99.9% 업타임 보장
- **확장성**: 사용자 증가에 따른 자동 스케일링

**보안 요구사항:**
- **인증**: JWT 기반 토큰 인증
- **암호화**: AES-256 데이터 암호화
- **네트워크**: HTTPS/TLS 1.3 통신
- **감사**: 모든 사용자 활동 로깅

## 8. Data Requirements
**데이터 모델:**
- **사용자 데이터**: 프로필, 설정, 권한
- **비즈니스 데이터**: 핵심 비즈니스 로직
- **분석 데이터**: 사용자 행동, 성과 지표
- **시스템 데이터**: 로그, 감사, 백업

**데이터 플로우:**
- **수집**: 실시간 데이터 수집 및 검증
- **처리**: ETL 파이프라인을 통한 데이터 변환
- **저장**: 관계형/NoSQL 하이브리드 저장
- **분석**: ML 기반 인사이트 생성

## 9. Integration Requirements
**외부 시스템 연동:**
- **CRM 시스템**: Salesforce, HubSpot 연동
- **결제 시스템**: Stripe, PayPal 연동
- **이메일 서비스**: SendGrid, Mailchimp 연동
- **분석 도구**: Google Analytics, Mixpanel 연동

**API 명세:**
- **RESTful API**: 표준 HTTP 메서드
- **GraphQL**: 효율적인 데이터 쿼리
- **Webhook**: 실시간 이벤트 알림
- **SDK**: JavaScript, Python, Java SDK 제공

## 10. Success Metrics
**핵심 성공 지표:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**추가 측정 지표:**
- **사용자 참여도**: DAU/MAU 비율 30% 이상
- **기능 활용도**: 핵심 기능 사용률 80% 이상
- **사용자 만족도**: NPS 점수 50 이상
- **기술적 성과**: 시스템 안정성 99.9% 유지

**측정 방법:**
- **A/B 테스트**: 기능별 성과 비교
- **사용자 피드백**: 정기적 설문조사
- **데이터 분석**: 사용자 행동 패턴 분석
- **성과 리뷰**: 분기별 KPI 평가

---

*이 문서는 Claude Sonnet 4.5 AI가 사용자 입력 데이터를 분석하여 생성했습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*
*AI 모델: Claude-3-5-Sonnet-20241022*`;
            }
            
            if (docType === 'TRD') {
                // AI 분석 시뮬레이션을 위한 추가 데이터 생성
                const systemArchitecture = generateSystemArchitecture(input);
                const technologyStack = generateTechnologyStack(input);
                const dataArchitecture = generateDataArchitecture(input);
                const securityFramework = generateSecurityFramework(input);
                const performanceSpecs = generatePerformanceSpecs(input);
                const deploymentStrategy = generateDeploymentStrategy(input);
                
                return `# Technical Requirements Document

## 1. Technical Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 혁신적인 기술적 솔루션입니다. ${input.capability ? `팀의 역량인 ${input.capability}을 활용하여 구현하며,` : '사용자 팀의 역량을 기반으로 구현하며,'} 최신 기술 트렌드와 확장 가능한 아키텍처를 통해 지속 가능한 기술적 가치를 창출하는 것을 목표로 합니다.

**기술 비전:**
- 마이크로서비스 기반 확장 가능한 아키텍처
- AI/ML 기반 지능형 시스템
- 클라우드 네이티브 설계 원칙

## 2. System Architecture
${systemArchitecture}

## 3. Technology Stack
${technologyStack}

## 4. Data Architecture
${dataArchitecture}

## 5. API Design
**API 설계 원칙:**
- **RESTful API**: 표준 HTTP 메서드 (GET, POST, PUT, DELETE)
- **GraphQL**: 효율적인 데이터 쿼리 및 실시간 구독
- **인증**: JWT + OAuth 2.0 기반 토큰 인증
- **Rate Limiting**: 사용자별 1000 req/min, API별 10000 req/min
- **버전 관리**: API v1, v2 호환성 유지

**API 엔드포인트 설계:**
- **인증 API**: `/api/v1/auth/*` - 로그인, 회원가입, 토큰 갱신
- **사용자 API**: `/api/v1/users/*` - 프로필 관리, 설정
- **비즈니스 API**: `/api/v1/business/*` - 핵심 비즈니스 로직
- **분석 API**: `/api/v1/analytics/*` - 데이터 분석 및 리포트

**API 문서화:**
- **Swagger/OpenAPI**: 자동 생성 API 문서
- **Postman Collection**: 개발팀용 API 테스트
- **SDK 제공**: JavaScript, Python, Java SDK

## 6. Security Requirements
${securityFramework}

## 7. Performance Requirements
${performanceSpecs}

## 8. Scalability & Availability
**확장성 설계:**
- **수평적 확장**: 마이크로서비스 기반 독립적 스케일링
- **로드 밸런싱**: Nginx + HAProxy 기반 트래픽 분산
- **자동 스케일링**: Kubernetes HPA 기반 동적 리소스 조정
- **캐싱 전략**: Redis 클러스터 + CDN 기반 다층 캐싱

**고가용성 설계:**
- **Multi-AZ 배포**: 3개 가용영역 분산 배포
- **장애 복구**: RTO 15분, RPO 5분 목표
- **백업 전략**: 일일 전체 백업 + 실시간 증분 백업
- **모니터링**: Prometheus + Grafana 기반 실시간 모니터링

**부하 분산:**
- **API Gateway**: Kong 기반 API 라우팅 및 제한
- **데이터베이스**: 읽기 전용 복제본 3개 구성
- **파일 저장**: S3 기반 분산 파일 시스템
- **CDN**: CloudFront 기반 글로벌 콘텐츠 배포

## 9. Development Guidelines
**개발 환경:**
- **IDE**: VS Code, IntelliJ IDEA 권장
- **코딩 컨벤션**: ESLint, Prettier 기반 자동 포맷팅
- **Git 워크플로우**: GitFlow 브랜치 전략
- **코드 리뷰**: Pull Request 필수, 2명 이상 승인

**테스팅 전략:**
- **단위 테스트**: Jest, JUnit 기반 90% 커버리지 목표
- **통합 테스트**: API 테스트 자동화
- **E2E 테스트**: Cypress 기반 사용자 시나리오 테스트
- **성능 테스트**: JMeter 기반 부하 테스트

**CI/CD 파이프라인:**
- **빌드**: Docker 기반 멀티 스테이지 빌드
- **테스트**: 자동화된 테스트 실행 및 품질 게이트
- **배포**: Blue-Green 배포 전략
- **롤백**: 자동 롤백 메커니즘

## 10. Implementation Roadmap
${deploymentStrategy}

---

*이 문서는 Claude Sonnet 4.5 AI가 사용자 입력 데이터를 분석하여 생성했습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*
*AI 모델: Claude-3-5-Sonnet-20241022*`;
            }
        }

        // 사용자 입력 기반 BRD 내용 생성
        function createBRDContent(input) {
            return `# Business Requirements Document

## 1. Executive Summary
${input.insight ? `이 프로젝트는 "${input.insight}"라는 핵심 인사이트를 바탕으로 시작되었습니다.` : '이 프로젝트는 사용자의 핵심 인사이트를 바탕으로 시작되었습니다.'} ${input.evidence ? `검증된 근거에 따르면 ${input.evidence}입니다.` : '사용자가 제공한 검증 근거를 바탕으로 합니다.'} 이를 통해 비즈니스 가치를 창출하고 시장에서의 경쟁 우위를 확보하는 것을 목표로 합니다.

## 2. Business Objectives
${input.success_metric ? `- ${input.success_metric}` : '- 구체적인 성공 지표를 달성'}

**핵심 목표:**
- 사용자 입력 기반 비즈니스 목표 달성
- 시장에서의 경쟁 우위 확보
- 지속 가능한 성장 모델 구축

## 3. Market Analysis
**시장 기회:**
${input.insight ? `현재 시장에서 "${input.insight}"라는 문제가 존재하며, 이를 해결할 수 있는 기회가 있습니다.` : '사용자가 식별한 시장 기회를 분석합니다.'}

**타겟 고객:**
- 주요 고객층: 사용자 입력 기반 정의
- 고객 니즈: 핵심 문제 해결
- 시장 규모: 성장 잠재력 분석

## 4. Problem Statement
**핵심 문제:**
${input.insight ? `"${input.insight}"` : '사용자가 식별한 핵심 문제'}

**비즈니스 영향:**
- 현재 상황에서의 손실 및 기회비용
- 문제 지속 시 예상되는 부정적 영향
- 시급성 및 중요성

## 5. Proposed Solution
**솔루션 개요:**
${input.core_features ? `핵심 기능: ${input.core_features}` : '사용자가 제안한 핵심 기능을 기반으로 한 솔루션'}

**가치 제안:**
- 사용자 문제 해결
- 비즈니스 가치 창출
- 경쟁 우위 확보

## 6. Success Criteria
**정량적 KPI:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**정성적 지표:**
- 사용자 만족도 향상
- 시장 인지도 증대
- 브랜드 가치 상승

## 7. Stakeholders
**주요 이해관계자:**
- 프로젝트 스폰서
- 개발팀
- 사용자/고객
- 비즈니스 파트너

**역할 및 책임:**
- 의사결정권자: 전략적 방향 설정
- 실행팀: 구체적 구현
- 사용자: 피드백 및 검증

## 8. Constraints & Risks
**제약 사항:**
${input.principle ? `절대 원칙: ${input.principle}` : '사용자 정의 제약 사항'}

**주요 리스크:**
- 기술적 복잡성
- 시장 변화
- 자원 제약

**완화 방안:**
- 단계적 접근
- 지속적 모니터링
- 유연한 대응

## 9. Timeline & Milestones
**개발 단계:**
- Phase 1: 기획 및 설계 (1-2개월)
- Phase 2: 개발 및 테스트 (2-3개월)
- Phase 3: 출시 및 운영 (1개월)

**주요 마일스톤:**
- MVP 출시
- 베타 테스트 완료
- 정식 출시

## 10. Budget & Resources
**필요 리소스:**
${input.capability ? `팀 역량: ${input.capability}` : '사용자 팀의 역량을 기반으로 한 리소스 계획'}

**예산 추정:**
- 개발비: 팀 규모 및 기간에 따라 산정
- 마케팅비: 시장 진입 전략
- 운영비: 지속적 서비스 운영

**투자 대비 효과:**
- ROI 예상치
- 비용 절감 효과
- 수익 창출 잠재력

---

*이 문서는 사용자 입력 데이터를 바탕으로 생성되었습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
        }

        // BRD 표시
        function displayBRD(content) {
            document.getElementById('brdGenerating').style.display = 'none';
            document.getElementById('brdContentWrapper').style.display = 'block';
            document.getElementById('brdContent').innerHTML = convertMarkdownToHTML(content);
            document.getElementById('brdBadge').textContent = '생성 완료';
            document.getElementById('brdBadge').className = 'document-badge badge-generated';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // BRD 오류 표시
        function showBRDError(errorMessage) {
            document.getElementById('brdGenerating').style.display = 'none';
            document.getElementById('brdError').style.display = 'block';
            document.getElementById('brdErrorText').textContent = errorMessage;
        }

        // BRD 재생성
        async function regenerateBRD() {
            document.getElementById('brdContentWrapper').style.display = 'none';
            document.getElementById('brdGenerating').style.display = 'block';
            document.getElementById('brdBadge').textContent = '생성 중';
            document.getElementById('brdBadge').className = 'document-badge badge-generating';
            
            await generateBRD();
        }

        // BRD 재시도
        async function retryBRDGeneration() {
            document.getElementById('brdError').style.display = 'none';
            document.getElementById('brdGenerating').style.display = 'block';
            
            await generateBRD();
        }

        // BRD 승인 및 PRD 생성
        async function approveBRD() {
            projectData.approveDocument('brd');
            projectData.updateStatus('prd_generating');
            updateWorkflowStatus('prd');
            
            // PRD 화면으로 전환
            document.getElementById('brdScreen').classList.remove('active');
            document.getElementById('prdScreen').classList.add('active');
            
            document.getElementById('brdBadge').textContent = '승인됨';
            document.getElementById('brdBadge').className = 'document-badge badge-approved';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // PRD 생성 시작
            await generatePRD();
        }

        // PRD 생성
        async function generatePRD() {
            try {
                // AI 프롬프트 생성
                const prompt = createPRDPrompt();
                
                // 실제 AI API 호출 (현재는 데모 모드)
                const prdContent = await callAIAPI(prompt, 'PRD');

                projectData.completeDocumentGeneration('prd', prdContent);
                displayPRD(prdContent);

            } catch (error) {
                console.error('PRD 생성 오류:', error);
                showPRDError(error.message);
            }
        }

        // PRD 프롬프트 생성
        function createPRDPrompt() {
            const input = projectData.user_input;
            const brd = projectData.documents.brd.content;
            return `당신은 제품 관리 및 요구사항 분석 전문가입니다. 아래의 BRD와 사용자 입력을 바탕으로 상세한 Product Requirements Document(PRD)를 작성해주세요.

**BRD:**
${brd}

**원본 사용자 입력:**
- 핵심 인사이트: ${input.insight}
- 검증 근거: ${input.evidence}
- 팀 역량: ${input.capability}
- 절대 원칙: ${input.principle}
- 성공 정의: ${input.success_metric}
- 핵심 기능: ${input.core_features}

---

**PRD 작성 가이드라인:**

## 1. Product Overview
- 제품 비전
- 제품 목표
- 타겟 사용자

## 2. User Personas
- 주요 페르소나 (3-4개)
- 각 페르소나의 니즈와 페인 포인트
- 사용 시나리오

## 3. Feature Requirements
각 기능마다 다음을 포함:
- 기능 이름 및 설명
- 우선순위 (P0/P1/P2)
- 사용자 스토리
- 인수 기준
- 의존성

## 4. User Stories
- Epic별 사용자 스토리
- 스토리 포인트
- Definition of Done

## 5. User Experience
- 주요 사용자 플로우
- 화면 구성 및 레이아웃
- 인터랙션 설계

## 6. Functional Requirements
- 상세 기능 명세
- 입력/출력 정의
- 비즈니스 규칙

## 7. Non-Functional Requirements
- 성능 요구사항
- 보안 요구사항
- 확장성 및 가용성
- 접근성

## 8. Data Requirements
- 데이터 모델
- 데이터 플로우
- 저장소 요구사항

## 9. Integration Requirements
- 외부 시스템 연동
- API 명세
- 데이터 동기화

## 10. Success Metrics
- 기능별 성공 지표
- 측정 방법
- 목표값

**중요:**
- 개발팀이 바로 구현할 수 있을 만큼 구체적으로 작성하세요
- 각 요구사항은 명확하고 검증 가능해야 합니다
- 우선순위를 명확히 하세요
- 마크다운 형식으로 작성하세요`;
        }

        // 사용자 입력 기반 PRD 내용 생성
        function createPRDContent(input) {
            return `# Product Requirements Document

## 1. Product Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 제품입니다. ${input.core_features ? `핵심 기능으로는 ${input.core_features}가 있습니다.` : '사용자가 정의한 핵심 기능을 포함합니다.'}

## 2. User Personas
**주요 사용자:**
- 타겟 고객: 사용자 입력 기반 정의
- 사용자 니즈: ${input.insight ? `"${input.insight}"` : '핵심 문제 해결'}
- 사용 패턴: 예상 사용 시나리오

## 3. Feature Requirements
**핵심 기능:**
${input.core_features ? `- ${input.core_features}` : '- 사용자 정의 핵심 기능'}

**우선순위:**
- P0: 핵심 문제 해결 기능
- P1: 사용자 경험 향상 기능
- P2: 부가 가치 기능

## 4. User Stories
**사용자 시나리오:**
- 사용자는 ${input.insight ? `"${input.insight}"` : '핵심 문제'}를 해결할 수 있다
- 사용자는 ${input.core_features ? `"${input.core_features}"` : '핵심 기능'}을 활용할 수 있다
- 사용자는 ${input.success_metric ? `"${input.success_metric}"` : '성공 지표'}를 달성할 수 있다

## 5. User Experience
**사용자 경험 설계:**
- 직관적인 인터페이스
- ${input.principle ? `"${input.principle}"` : '사용자 원칙'} 준수
- 효율적인 워크플로우

## 6. Functional Requirements
**기능적 요구사항:**
- 핵심 기능 구현
- 데이터 처리 및 분석
- 사용자 인터랙션
- 결과 제공 및 피드백

## 7. Non-Functional Requirements
**성능 요구사항:**
- 응답 시간: 3초 이내
- 가용성: 99% 이상
- 확장성: 사용자 증가 대응
- 보안: 데이터 보호

## 8. Data Requirements
**데이터 요구사항:**
- 사용자 입력 데이터
- 처리 결과 데이터
- 분석 데이터
- 히스토리 데이터

## 9. Integration Requirements
**연동 요구사항:**
- 외부 시스템 연동
- API 연동
- 데이터 동기화
- 실시간 처리

## 10. Success Metrics
**성공 지표:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**측정 방법:**
- 사용자 피드백
- 사용량 분석
- 성과 측정
- 지속적 개선

---

*이 문서는 사용자 입력 데이터를 바탕으로 생성되었습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
        }

        // PRD 표시
        function displayPRD(content) {
            document.getElementById('prdGenerating').style.display = 'none';
            document.getElementById('prdContentWrapper').style.display = 'block';
            document.getElementById('prdContent').innerHTML = convertMarkdownToHTML(content);
            document.getElementById('prdBadge').textContent = '생성 완료';
            document.getElementById('prdBadge').className = 'document-badge badge-generated';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // PRD 오류 표시
        function showPRDError(errorMessage) {
            document.getElementById('prdGenerating').style.display = 'none';
            document.getElementById('prdError').style.display = 'block';
            document.getElementById('prdErrorText').textContent = errorMessage;
        }

        // PRD 재생성
        async function regeneratePRD() {
            document.getElementById('prdContentWrapper').style.display = 'none';
            document.getElementById('prdGenerating').style.display = 'block';
            document.getElementById('prdBadge').textContent = '생성 중';
            document.getElementById('prdBadge').className = 'document-badge badge-generating';
            
            await generatePRD();
        }

        // PRD 재시도
        async function retryPRDGeneration() {
            document.getElementById('prdError').style.display = 'none';
            document.getElementById('prdGenerating').style.display = 'block';
            
            await generatePRD();
        }

        // PRD 승인 및 TRD 생성
        async function approvePRD() {
            projectData.approveDocument('prd');
            projectData.updateStatus('trd_generating');
            updateWorkflowStatus('trd');
            
            document.getElementById('prdScreen').classList.remove('active');
            document.getElementById('trdScreen').classList.add('active');
            
            document.getElementById('prdBadge').textContent = '승인됨';
            document.getElementById('prdBadge').className = 'document-badge badge-approved';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            await generateTRD();
        }

        // TRD 생성
        async function generateTRD() {
            try {
                // AI 프롬프트 생성
                const prompt = createTRDPrompt();
                
                // 실제 AI API 호출 (현재는 데모 모드)
                const trdContent = await callAIAPI(prompt, 'TRD');

                projectData.completeDocumentGeneration('trd', trdContent);
                displayTRD(trdContent);

            } catch (error) {
                console.error('TRD 생성 오류:', error);
                showTRDError(error.message);
            }
        }

        // TRD 프롬프트 생성
        function createTRDPrompt() {
            const input = projectData.user_input;
            const brd = projectData.documents.brd.content;
            const prd = projectData.documents.prd.content;
            return `당신은 소프트웨어 아키텍트 및 기술 설계 전문가입니다. BRD와 PRD를 바탕으로 Technical Requirements Document(TRD)를 작성해주세요.

**BRD 요약:**
${brd.substring(0, 1000)}...

**PRD 요약:**
${prd.substring(0, 1000)}...

**팀 역량:**
${input.capability}

---

**TRD 작성 가이드라인:**

## 1. Technical Overview
- 기술 비전
- 아키텍처 원칙
- 기술 스택 선정 이유

## 2. System Architecture
- 전체 시스템 아키텍처
- 주요 컴포넌트
- 데이터 플로우

## 3. Technology Stack
- Frontend 기술
- Backend 기술
- 데이터베이스
- 인프라 및 DevOps
- 외부 서비스

## 4. Data Architecture
- 데이터베이스 스키마
- 데이터 모델링
- 캐싱 전략
- 백업 및 복구

## 5. API Design
- RESTful API 설계
- 인증/인가
- Rate limiting
- API 버전 관리

## 6. Security Requirements
- 인증 및 권한
- 데이터 암호화
- 보안 취약점 대응
- 컴플라이언스

## 7. Performance Requirements
- 응답 시간 목표
- 처리량 목표
- 동시 사용자 수
- 최적화 전략

## 8. Scalability & Availability
- 확장성 설계
- 로드 밸런싱
- 장애 복구
- 모니터링

## 9. Development Guidelines
- 코딩 컨벤션
- Git 워크플로우
- 테스팅 전략
- CI/CD 파이프라인

## 10. Implementation Roadmap
- Phase별 기술 구현 계획
- 마일스톤
- 기술 부채 관리

**중요:**
- 실제 구현 가능한 구체적인 기술 스펙을 제시하세요
- 팀의 역량을 고려한 현실적인 기술 선택을 하세요
- 확장성과 유지보수성을 고려하세요
- 마크다운 형식으로 작성하세요`;
        }

        // 사용자 입력 기반 TRD 내용 생성
        function createTRDContent(input) {
            return `# Technical Requirements Document

## 1. Technical Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 기술적 솔루션입니다. ${input.capability ? `팀의 역량인 ${input.capability}을 활용하여 구현합니다.` : '사용자 팀의 역량을 기반으로 구현합니다.'}

## 2. System Architecture
**전체 아키텍처:**
- **Frontend**: 사용자 인터페이스
- **Backend**: 비즈니스 로직 처리
- **Database**: 데이터 저장 및 관리
- **Integration**: 외부 시스템 연동

## 3. Technology Stack
**기술 스택 선택 기준:**
${input.capability ? `- 팀 역량: ${input.capability}` : '- 팀 역량 기반 기술 선택'}

**권장 기술:**
- **Frontend**: React.js, Vue.js, Angular
- **Backend**: Node.js, Python, Java
- **Database**: PostgreSQL, MySQL, MongoDB
- **Infrastructure**: Docker, Kubernetes

## 4. Data Architecture
**데이터 설계:**
- **사용자 데이터**: 프로필 및 설정
- **비즈니스 데이터**: 핵심 비즈니스 로직
- **분석 데이터**: 성과 및 지표
- **로그 데이터**: 시스템 모니터링

## 5. API Design
**API 설계 원칙:**
- **RESTful API**: 표준 HTTP 메서드
- **인증**: JWT 또는 OAuth 2.0
- **Rate Limiting**: 서비스 보호
- **버전 관리**: API 호환성

## 6. Security Requirements
**보안 요구사항:**
${input.principle ? `- ${input.principle} 준수` : '- 사용자 정의 보안 원칙'}

**보안 구현:**
- **인증**: 사용자 인증 시스템
- **암호화**: 데이터 암호화
- **HTTPS**: 통신 보안
- **데이터 보호**: 개인정보 보호

## 7. Performance Requirements
**성능 목표:**
${input.success_metric ? `- ${input.success_metric} 달성을 위한 성능 최적화` : '- 사용자 정의 성공 지표 달성'}

**성능 지표:**
- **응답 시간**: 3초 이내
- **처리량**: 예상 사용자 수 대응
- **가용성**: 99% 이상
- **확장성**: 사용자 증가 대응

## 8. Scalability & Availability
**확장성 설계:**
- **로드 밸런싱**: 트래픽 분산
- **자동 스케일링**: 리소스 자동 조정
- **장애 복구**: 고가용성 보장
- **모니터링**: 실시간 상태 확인

## 9. Development Guidelines
**개발 가이드라인:**
- **코딩 컨벤션**: 팀 표준 준수
- **Git 워크플로우**: 협업 프로세스
- **테스팅**: 품질 보증
- **CI/CD**: 자동화된 배포

## 10. Implementation Roadmap
**구현 계획:**
- **Phase 1**: 기본 인프라 구축 (1-2개월)
- **Phase 2**: 핵심 기능 개발 (2-3개월)
- **Phase 3**: 통합 및 테스트 (1개월)
- **Phase 4**: 출시 및 운영 (지속적)

**마일스톤:**
- MVP 개발 완료
- 베타 테스트 완료
- 정식 출시
- 운영 안정화

---

*이 문서는 사용자 입력 데이터를 바탕으로 생성되었습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
        }

        // TRD 표시
        function displayTRD(content) {
            document.getElementById('trdGenerating').style.display = 'none';
            document.getElementById('trdContentWrapper').style.display = 'block';
            document.getElementById('trdContent').innerHTML = convertMarkdownToHTML(content);
            document.getElementById('trdBadge').textContent = '생성 완료';
            document.getElementById('trdBadge').className = 'document-badge badge-generated';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // TRD 오류 표시
        function showTRDError(errorMessage) {
            document.getElementById('trdGenerating').style.display = 'none';
            document.getElementById('trdError').style.display = 'block';
            document.getElementById('trdErrorText').textContent = errorMessage;
        }

        // TRD 재생성
        async function regenerateTRD() {
            document.getElementById('trdContentWrapper').style.display = 'none';
            document.getElementById('trdGenerating').style.display = 'block';
            document.getElementById('trdBadge').textContent = '생성 중';
            document.getElementById('trdBadge').className = 'document-badge badge-generating';
            
            await generateTRD();
        }

        // TRD 재시도
        async function retryTRDGeneration() {
            document.getElementById('trdError').style.display = 'none';
            document.getElementById('trdGenerating').style.display = 'block';
            
            await generateTRD();
        }

        // 마크다운을 HTML로 변환 (간단한 구현)
        function convertMarkdownToHTML(markdown) {
            let html = markdown;
            
            // 헤딩
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h2>$1</h2>');
            
            // 볼드
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'};
            
            // 이탤릭
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // 리스트
            html = html.replace(/^\- (.*$)/gim, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            
            // 줄바꿈
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            return html;
        }

        // TRD 건너뛰기
        function skipToComplete() {
            projectData.updateStatus('completed');
            document.getElementById('prdScreen').classList.remove('active');
            document.getElementById('finalCompletionScreen').classList.add('active');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // 프로젝트 완료
        function completeProject() {
            projectData.approveDocument('trd');
            projectData.updateStatus('completed');
            
            document.getElementById('trdScreen').classList.remove('active');
            document.getElementById('finalCompletionScreen').classList.add('active');
            
            document.getElementById('trdBadge').textContent = '승인됨';
            document.getElementById('trdBadge').className = 'document-badge badge-approved';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            console.log('🎉 프로젝트 완료!', projectData.getSummary());
        }

        // 데모 데이터 생성 (테스트용)
        function generateDemoData() {
            const demoBRD = `# Business Requirements Document

## 1. Executive Summary
이 프로젝트는 AI 기반 리뷰 검증 시스템을 통해 온라인 쇼핑의 신뢰성을 높이는 것을 목표로 합니다.

## 2. Business Objectives
- 가짜 리뷰 탐지율 95% 이상 달성
- 사용자 구매 전환율 30% 향상
- 플랫폼 신뢰도 지수 4.5/5 이상

## 3. Market Analysis
- 온라인 쇼핑 시장 규모: 연 500조원
- 가짜 리뷰로 인한 손실: 연 50조원
- 타겟 고객: 20-40대 온라인 쇼핑 이용자

## 4. Problem Statement
현재 온라인 쇼핑에서 가짜 리뷰로 인한 신뢰성 문제가 심각합니다.

## 5. Proposed Solution
AI 기반 리뷰 검증 시스템을 통해 실제 구매자만의 검증된 리뷰를 제공합니다.

## 6. Success Criteria
- 월간 활성 사용자 5만명
- 리뷰 신뢰도 평가 4.5/5 이상
- 구매 전환율 30% 향상

## 7. Stakeholders
- 제품 관리자
- 개발팀
- 마케팅팀
- 고객 서비스팀

## 8. Constraints & Risks
- 개발 기간: 6개월
- 예산: 5억원
- 기술적 복잡성

## 9. Timeline & Milestones
- 1단계: 프로토타입 개발 (2개월)
- 2단계: 베타 테스트 (1개월)
- 3단계: 정식 출시 (3개월)

## 10. Budget & Resources
- 개발비: 3억원
- 마케팅비: 1억원
- 운영비: 1억원`;

            const demoPRD = `# Product Requirements Document

## 1. Product Overview
AI 기반 리뷰 검증 시스템으로 온라인 쇼핑의 신뢰성을 높이는 제품입니다.

## 2. User Personas
- **주니어 쇼핑족**: 20-30대, 온라인 쇼핑 빈번
- **가족 쇼핑족**: 30-40대, 가족용품 구매
- **프리미엄 쇼핑족**: 30-50대, 고가 제품 구매

## 3. Feature Requirements
- **P0**: 리뷰 검증 알고리즘
- **P0**: 구매 이력 확인
- **P1**: 신뢰도 점수 표시
- **P1**: 검증 배지 시스템

## 4. User Stories
- 사용자는 구매한 제품에 대한 리뷰를 작성할 수 있다
- 사용자는 리뷰의 신뢰도를 확인할 수 있다
- 사용자는 검증된 리뷰를 우선적으로 볼 수 있다

## 5. User Experience
- 직관적인 리뷰 작성 인터페이스
- 명확한 신뢰도 표시
- 빠른 검증 프로세스

## 6. Functional Requirements
- 리뷰 텍스트 분석
- 구매 이력 매칭
- 신뢰도 점수 계산
- 검증 배지 부여

## 7. Non-Functional Requirements
- 응답 시간: 2초 이내
- 가용성: 99.9%
- 보안: 개인정보 보호

## 8. Data Requirements
- 구매 이력 데이터
- 리뷰 텍스트 데이터
- 사용자 프로필 데이터

## 9. Integration Requirements
- 쇼핑몰 API 연동
- 결제 시스템 연동
- 사용자 인증 시스템

## 10. Success Metrics
- 리뷰 검증 정확도: 95%
- 사용자 만족도: 4.5/5
- 시스템 가용성: 99.9%`;

            const demoTRD = `# Technical Requirements Document

## 1. Technical Overview
마이크로서비스 아키텍처 기반의 AI 리뷰 검증 시스템입니다.

## 2. System Architecture
- **Frontend**: React.js + TypeScript
- **Backend**: Node.js + Express
- **AI Engine**: Python + TensorFlow
- **Database**: PostgreSQL + Redis

## 3. Technology Stack
- **Frontend**: React, TypeScript, Material-UI
- **Backend**: Node.js, Express, TypeScript
- **AI/ML**: Python, TensorFlow, scikit-learn
- **Database**: PostgreSQL, Redis
- **Infrastructure**: Docker, Kubernetes

## 4. Data Architecture
- **PostgreSQL**: 사용자 데이터, 구매 이력
- **Redis**: 세션, 캐시
- **MongoDB**: 리뷰 텍스트 데이터
- **S3**: 파일 저장소

## 5. API Design
- **RESTful API**: 표준 HTTP 메서드
- **인증**: JWT 토큰 기반
- **Rate Limiting**: 1000 req/min
- **API 버전**: v1

## 6. Security Requirements
- **인증**: JWT + OAuth 2.0
- **암호화**: AES-256
- **HTTPS**: TLS 1.3
- **데이터 보호**: GDPR 준수

## 7. Performance Requirements
- **응답 시간**: 2초 이내
- **처리량**: 1000 req/sec
- **동시 사용자**: 10,000명
- **최적화**: CDN, 캐싱

## 8. Scalability & Availability
- **로드 밸런싱**: Nginx
- **자동 스케일링**: Kubernetes HPA
- **장애 복구**: Multi-AZ 배포
- **모니터링**: Prometheus + Grafana

## 9. Development Guidelines
- **코딩 컨벤션**: ESLint + Prettier
- **Git 워크플로우**: GitFlow
- **테스팅**: Jest + Cypress
- **CI/CD**: GitHub Actions

## 10. Implementation Roadmap
- **Phase 1**: 기본 인프라 구축 (2개월)
- **Phase 2**: AI 모델 개발 (2개월)
- **Phase 3**: 통합 및 테스트 (2개월)`;

            // 데모 데이터를 프로젝트에 저장
            projectData.completeDocumentGeneration('brd', demoBRD);
            projectData.completeDocumentGeneration('prd', demoPRD);
            projectData.completeDocumentGeneration('trd', demoTRD);
            
            console.log('🎯 데모 데이터 생성 완료!');
            alert('✅ 데모 데이터가 생성되었습니다!\n\n이제 PDF 저장 기능을 테스트할 수 있습니다.');
        }

        // 이벤트 리스너 설정
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM 로드 완료, 초기화 시작');
            
            // 저장된 데이터 불러오기
            loadSavedData();
            
            // DOM 요소 존재 확인
            const nextBtn = document.getElementById('nextBtn');
            console.log('🔍 DOM 요소 확인:', {
                nextBtn: !!nextBtn,
                nextBtnId: nextBtn ? nextBtn.id : 'N/A',
                nextBtnDisabled: nextBtn ? nextBtn.disabled : 'N/A'
            });
            
            // 각 textarea에 이벤트 리스너 추가
            const fields = ['insight', 'validation', 'capability', 'principle', 'success', 'feature'];
            fields.forEach(fieldId => {
                const textarea = document.getElementById(fieldId);
                if (textarea) {
                    console.log(`📝 ${fieldId} 필드에 이벤트 리스너 추가`);
                    textarea.addEventListener('input', function() {
                        console.log(`🔄 ${fieldId} 입력 이벤트 발생`);
                        updateCharCount(fieldId);
                    });
                    textarea.addEventListener('blur', autoSave);
                } else {
                    console.error(`❌ ${fieldId} 필드를 찾을 수 없습니다`);
                }
            });

            // 초기 진행률 업데이트
            updateProgress();
            updateNextButton();

            // 개발자 도구용 전역 함수 노출
            window.projectData = projectData;
            window.resetProject = resetProject;
            window.downloadProjectData = downloadProjectData;
            window.generateDemoData = generateDemoData;
            window.currentStep = currentStep; // 디버깅용 전역 노출
            window.forceEnableNext = function() {
                const btn = document.getElementById('nextBtn');
                if (btn) {
                    btn.disabled = false;
                    console.log('🔧 수동으로 다음 버튼 활성화');
                }
            };
            window.testButton = function() {
                console.log('🧪 버튼 테스트 시작');
                const btn = document.getElementById('nextBtn');
                const field = document.getElementById('insight');
                console.log('버튼:', btn);
                console.log('필드:', field);
                console.log('현재 단계:', currentStep);
                console.log('현재 필드 ID:', getCurrentFieldId());
                updateNextButton();
            };
            window.setAPIKey = function(key) {
                localStorage.setItem('claude_api_key', key);
                console.log('🔑 API 키가 설정되었습니다');
            };
            window.clearAPIKey = function() {
                localStorage.removeItem('claude_api_key');
                console.log('🗑️ API 키가 삭제되었습니다');
            };
            window.testAPI = async function() {
                console.log('🧪 API 테스트 시작');
                const testPrompt = '간단한 테스트입니다.';
                try {
                    const result = await callAIAPI(testPrompt, 'TEST');
                    console.log('✅ API 테스트 성공:', result.substring(0, 100) + '...');
                } catch (error) {
                    console.error('❌ API 테스트 실패:', error);
                }
            };
            window.testPRDHelpers = function() {
                console.log('🧪 PRD 헬퍼 함수 테스트 시작');
                const testInput = {
                    insight: '테스트 인사이트',
                    evidence: '테스트 근거',
                    capability: '테스트 역량',
                    principle: '테스트 원칙',
                    success_metric: '테스트 성공지표',
                    core_features: '테스트 기능'
                };
                
                try {
                    const personas = generateUserPersonas(testInput);
                    const features = generateFeatureAnalysis(testInput);
                    const stories = generateUserStories(testInput);
                    const specs = generateTechnicalSpecs(testInput);
                    
                    console.log('✅ PRD 헬퍼 함수 테스트 성공');
                    console.log('Personas:', personas.substring(0, 100) + '...');
                    console.log('Features:', features.substring(0, 100) + '...');
                    console.log('Stories:', stories.substring(0, 100) + '...');
                    console.log('Specs:', specs.substring(0, 100) + '...');
                } catch (error) {
                    console.error('❌ PRD 헬퍼 함수 테스트 실패:', error);
                }
            };
            window.testTRDHelpers = function() {
                console.log('🧪 TRD 헬퍼 함수 테스트 시작');
                const testInput = {
                    insight: '테스트 인사이트',
                    evidence: '테스트 근거',
                    capability: '테스트 역량',
                    principle: '테스트 원칙',
                    success_metric: '테스트 성공지표',
                    core_features: '테스트 기능'
                };
                
                try {
                    const architecture = generateSystemArchitecture(testInput);
                    const techStack = generateTechnologyStack(testInput);
                    const dataArch = generateDataArchitecture(testInput);
                    const security = generateSecurityFramework(testInput);
                    const performance = generatePerformanceSpecs(testInput);
                    const deployment = generateDeploymentStrategy(testInput);
                    
                    console.log('✅ TRD 헬퍼 함수 테스트 성공');
                    console.log('Architecture:', architecture.substring(0, 100) + '...');
                    console.log('TechStack:', techStack.substring(0, 100) + '...');
                    console.log('DataArch:', dataArch.substring(0, 100) + '...');
                    console.log('Security:', security.substring(0, 100) + '...');
                    console.log('Performance:', performance.substring(0, 100) + '...');
                    console.log('Deployment:', deployment.substring(0, 100) + '...');
                } catch (error) {
                    console.error('❌ TRD 헬퍼 함수 테스트 실패:', error);
                }
            };
            window.testFullWorkflow = async function() {
                console.log('🧪 전체 워크플로우 테스트 시작');
                try {
                    // 1. BRD 생성 테스트
                    console.log('1️⃣ BRD 생성 테스트');
                    const brdPrompt = createBRDPrompt();
                    const brdResult = await callAIAPI(brdPrompt, 'BRD');
                    console.log('✅ BRD 생성 성공:', brdResult.substring(0, 100) + '...');
                    
                    // 2. PRD 생성 테스트
                    console.log('2️⃣ PRD 생성 테스트');
                    const prdPrompt = createPRDPrompt();
                    const prdResult = await callAIAPI(prdPrompt, 'PRD');
                    console.log('✅ PRD 생성 성공:', prdResult.substring(0, 100) + '...');
                    
                    // 3. TRD 생성 테스트
                    console.log('3️⃣ TRD 생성 테스트');
                    const trdPrompt = createTRDPrompt();
                    const trdResult = await callAIAPI(trdPrompt, 'TRD');
                    console.log('✅ TRD 생성 성공:', trdResult.substring(0, 100) + '...');
                    
                    console.log('🎉 전체 워크플로우 테스트 완료!');
                } catch (error) {
                    console.error('❌ 전체 워크플로우 테스트 실패:', error);
                }
            };
            
            console.log('🎯 제품 문서 생성 시스템 초기화 완료');
            console.log('💡 개발자 도구 명령어:');
            console.log('  - projectData: 현재 프로젝트 데이터 확인');
            console.log('  - projectData.getSummary(): 프로젝트 요약');
            console.log('  - downloadProjectData(): JSON 파일로 내보내기');
            console.log('  - resetProject(): 데이터 초기화');
            console.log('  - generateDemoData(): 데모 데이터 생성 (PDF 테스트용)');
        });

        // PDF 내보내기 함수들
        function exportBRDtoPDF() {
            downloadAsFile(projectData.documents.brd.content, 'BRD', 'md');
        }

        function exportPRDtoPDF() {
            downloadAsFile(projectData.documents.prd.content, 'PRD', 'md');
        }

        function exportTRDtoPDF() {
            downloadAsFile(projectData.documents.trd.content, 'TRD', 'md');
        }

        function downloadAsFile(content, docType, extension) {
            if (!content || content.trim() === '') {
                alert(`⚠️ ${docType} 문서가 아직 생성되지 않았습니다.\n먼저 문서를 생성해주세요.`);
                return;
            }

            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${docType}_${projectData.id}_${Date.now()}.${extension}`;
            link.click();
            URL.revokeObjectURL(url);
            
            console.log(`✅ ${docType} 다운로드 완료:`, link.download);
        }

        // 문서 복사 기능
        function copyBRD() {
            copyToClipboard(projectData.documents.brd.content, 'BRD');
        }

        function copyPRD() {
            copyToClipboard(projectData.documents.prd.content, 'PRD');
        }

        function copyTRD() {
            copyToClipboard(projectData.documents.trd.content, 'TRD');
        }

        function copyToClipboard(text, docType) {
            if (!text || text.trim() === '') {
                alert(`⚠️ ${docType} 문서가 아직 생성되지 않았습니다.\n먼저 문서를 생성해주세요.`);
                return;
            }

            navigator.clipboard.writeText(text).then(() => {
                alert(`✓ ${docType}가 클립보드에 복사되었습니다!`);
                console.log(`✅ ${docType} 복사 완료`);
            }).catch(err => {
                console.error('복사 실패:', err);
                alert('복사에 실패했습니다. 다시 시도해주세요.');
            });
        }

        // 모든 문서 다운로드
        function downloadAllDocuments() {
            let downloadCount = 0;
            
            // BRD
            if (projectData.documents.brd.status !== 'pending' && projectData.documents.brd.content) {
                downloadAsFile(projectData.documents.brd.content, 'BRD', 'md');
                downloadCount++;
            }
            
            // PRD
            if (projectData.documents.prd.status !== 'pending' && projectData.documents.prd.content) {
                setTimeout(() => {
                    downloadAsFile(projectData.documents.prd.content, 'PRD', 'md');
                }, 300);
                downloadCount++;
            }
            
            // TRD
            if (projectData.documents.trd.status !== 'pending' && projectData.documents.trd.content) {
                setTimeout(() => {
                    downloadAsFile(projectData.documents.trd.content, 'TRD', 'md');
                }, 600);
                downloadCount++;
            }
            
            // 프로젝트 데이터 JSON
            setTimeout(() => {
                const dataStr = projectData.exportJSON();
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `project_data_${projectData.id}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }, 900);
            
            if (downloadCount > 0) {
                alert(`📦 ${downloadCount}개 문서를 다운로드합니다.\n\n다운로드 폴더를 확인해주세요.`);
            } else {
                alert('⚠️ 다운로드할 문서가 없습니다.\n먼저 문서를 생성해주세요.');
            }
        }

        // 새 프로젝트 시작
        function startNewProject() {
            if (confirm('🔄 새 프로젝트를 시작하시겠습니까?\n\n현재 프로젝트는 로컬 저장소에 보관됩니다.')) {
                // 현재 프로젝트를 백업
                const backup = projectData.exportJSON();
                localStorage.setItem(`project_backup_${projectData.id}`, backup);
                
                // 새 프로젝트 생성
                projectData = new ProjectData();
                localStorage.setItem('projectData', JSON.stringify(projectData));
                
                // 페이지 새로고침
                location.reload();
            }
        }

        // 데이터 초기화 함수 (개발/테스트용)
        function resetProject() {
            if (confirm('⚠️ 모든 데이터를 초기화하시겠습니까?')) {
                localStorage.clear();
                projectData = new ProjectData();
                location.reload();
            }
        }

        // 데이터 내보내기 함수 (개발/테스트용)
        function downloadProjectData() {
            const dataStr = projectData.exportJSON();
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `project_${projectData.id}_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // 키보드 단축키
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                if (!document.getElementById('nextBtn').disabled) {
                    nextStep();
                }
            }
            
            // 개발자 단축키: Ctrl+Shift+D로 데이터 다운로드
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                downloadProjectData();
            }
            
            // 개발자 단축키: Ctrl+Shift+R로 데이터 리셋
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                resetProject();
            }
        });
    </script>
</body>
</html>
