<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제품 문서 생성 시스템</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Lato:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #f5f1ed 0%, #e8e1d9 100%);
            min-height: 100vh;
            padding: 20px;
            color: #4a4237;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            color: #6b5d52;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .subtitle {
            color: #8b7d6b;
            font-size: 1rem;
            font-weight: 300;
        }

        .progress-container {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .workflow-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .workflow-step {
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f5f1ed;
            font-size: 0.85rem;
            color: #8b7d6b;
            transition: all 0.3s ease;
        }

        .workflow-step.active {
            background: #c9b5a0;
            color: #fff;
            font-weight: 600;
        }

        .workflow-step.completed {
            background: #6b9b6b;
            color: #fff;
        }

        .workflow-arrow {
            color: #c9b5a0;
            font-size: 1.2rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e8e1d9;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #c9b5a0 0%, #a89075 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #8b7d6b;
        }

        .form-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(107, 93, 82, 0.1);
            display: none;
        }

        .form-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .question-number {
            font-family: 'Playfair Display', serif;
            font-size: 3rem;
            color: #c9b5a0;
            opacity: 0.3;
            margin-bottom: 10px;
        }

        .question-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: #6b5d52;
            margin-bottom: 10px;
        }

        .question-desc {
            color: #8b7d6b;
            font-size: 0.95rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .input-group {
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            padding: 16px;
            border: 2px solid #e8e1d9;
            border-radius: 12px;
            font-family: 'Lato', sans-serif;
            font-size: 1rem;
            color: #4a4237;
            background: #fefdfb;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #c9b5a0;
        }

        textarea.error {
            border-color: #d4a08a;
        }

        .char-counter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            font-size: 0.85rem;
            color: #8b7d6b;
        }

        .char-count {
            font-weight: 600;
        }

        .char-count.warning {
            color: #d4a08a;
        }

        .example-text {
            background: #f5f1ed;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #8b7d6b;
            margin-top: 12px;
            border-left: 3px solid #c9b5a0;
        }

        .example-label {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 16px 32px;
            border: none;
            border-radius: 12px;
            font-family: 'Lato', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9b5a0 0%, #a89075 100%);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(168, 144, 117, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #e8e1d9;
            color: #6b5d52;
        }

        .btn-secondary:hover {
            background: #d9d0c5;
        }

        .auto-save-indicator {
            text-align: center;
            color: #8b7d6b;
            font-size: 0.85rem;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .auto-save-indicator.show {
            opacity: 1;
        }

        .completion-screen {
            display: none;
            text-align: center;
            padding: 60px 40px;
        }

        .completion-screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .completion-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .completion-title {
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            color: #6b5d52;
            margin-bottom: 15px;
        }

        .completion-desc {
            color: #8b7d6b;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        /* BRD 생성 화면 */
        .document-screen {
            display: none;
            padding: 40px;
        }

        .document-screen.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .document-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e8e1d9;
        }

        .document-title {
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            color: #6b5d52;
        }

        .document-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .badge-generating {
            background: #fff5e6;
            color: #d4a08a;
        }

        .badge-generated {
            background: #e8f5e8;
            color: #6b9b6b;
        }

        .badge-approved {
            background: #c9b5a0;
            color: #fff;
        }

        .generating-animation {
            text-align: center;
            padding: 60px 20px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #e8e1d9;
            border-top-color: #c9b5a0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .generating-text {
            font-size: 1.2rem;
            color: #6b5d52;
            margin-bottom: 10px;
        }

        .generating-subtext {
            color: #8b7d6b;
            font-size: 0.9rem;
        }

        .document-content {
            background: #fefdfb;
            border: 2px solid #e8e1d9;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            min-height: 400px;
            line-height: 1.8;
            font-size: 1rem;
            color: #4a4237;
        }

        .document-content h2 {
            font-family: 'Playfair Display', serif;
            color: #6b5d52;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .document-content h2:first-child {
            margin-top: 0;
        }

        .document-content h3 {
            font-family: 'Playfair Display', serif;
            color: #8b7d6b;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .document-content p {
            margin-bottom: 15px;
        }

        .document-content ul, .document-content ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        .document-content li {
            margin-bottom: 8px;
        }

        .document-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-success {
            background: linear-gradient(135deg, #6b9b6b 0%, #5a8a5a 100%);
            color: #fff;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(107, 155, 107, 0.3);
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #c9b5a0;
            color: #6b5d52;
        }

        .btn-outline:hover {
            background: #c9b5a0;
            color: #fff;
        }

        .error-message {
            background: #ffe5e5;
            border: 2px solid #d4a08a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            color: #8b4a4a;
        }

        .error-message h3 {
            font-family: 'Playfair Display', serif;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .form-card {
                padding: 24px;
            }

            .question-title {
                font-size: 1.5rem;
            }

            .button-group {
                flex-direction: column;
            }

            .document-screen {
                padding: 24px;
            }

            .document-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .document-content {
                padding: 24px;
            }

            .document-actions {
                flex-direction: column;
            }

            .document-actions button {
                width: 100%;
            }

            .workflow-status {
                flex-wrap: wrap;
            }

            .workflow-step {
                font-size: 0.75rem;
                padding: 8px 4px;
            }

            .workflow-arrow {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>제품 문서 생성 시스템</h1>
            <p class="subtitle">5분만 투자하면 전문적인 BRD, PRD, TRD를 자동 생성합니다</p>
        </header>

        <div class="progress-container">
            <div class="workflow-status" id="workflowStatus">
                <div class="workflow-step" data-step="input">입력</div>
                <div class="workflow-arrow">→</div>
                <div class="workflow-step" data-step="brd">BRD</div>
                <div class="workflow-arrow">→</div>
                <div class="workflow-step" data-step="prd">PRD</div>
                <div class="workflow-arrow">→</div>
                <div class="workflow-step" data-step="trd">TRD</div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text">
                <span id="progressText">질문 1 / 6</span>
                <span id="progressPercent">0% 완료</span>
            </div>
        </div>

        <!-- Question 1 -->
        <div class="form-card active" data-step="1">
            <div class="question-number">01</div>
            <h2 class="question-title">핵심 인사이트</h2>
            <p class="question-desc">당신이 발견한 가장 중요한 통찰은 무엇인가요? 이 제품이 해결하려는 핵심 문제를 설명해주세요.</p>
            
            <div class="input-group">
                <textarea id="insight" maxlength="200" placeholder="예: 현재 시장에서 사용자들은..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="insightCount">0 / 200자</span>
                    <span id="insightStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    소비자의 80%가 제품 리뷰를 읽지만, 70%가 리뷰의 신뢰성을 의심합니다. 검증된 구매자의 실제 경험을 효과적으로 전달하는 방법이 필요합니다.
                </div>
            </div>
        </div>

        <!-- Question 2 -->
        <div class="form-card" data-step="2">
            <div class="question-number">02</div>
            <h2 class="question-title">검증 근거</h2>
            <p class="question-desc">이 인사이트를 뒷받침하는 데이터나 근거가 있나요? 시장 조사, 사용자 인터뷰, 데이터 분석 결과 등을 공유해주세요.</p>
            
            <div class="input-group">
                <textarea id="validation" maxlength="150" placeholder="예: 500명 사용자 인터뷰 결과..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="validationCount">0 / 150자</span>
                    <span id="validationStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    3개월간 500명 대상 설문 결과, 가짜 리뷰 때문에 구매를 포기한 경험이 평균 3.2회. A/B 테스트 결과 검증된 리뷰는 전환율 45% 향상.
                </div>
            </div>
        </div>

        <!-- Question 3 -->
        <div class="form-card" data-step="3">
            <div class="question-number">03</div>
            <h2 class="question-title">팀 역량</h2>
            <p class="question-desc">이 프로젝트를 성공시킬 수 있는 팀의 강점은 무엇인가요? 보유한 기술, 경험, 자원을 설명해주세요.</p>
            
            <div class="input-group">
                <textarea id="capability" maxlength="150" placeholder="예: 우리 팀은..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="capabilityCount">0 / 150자</span>
                    <span id="capabilityStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    AI/ML 전문가 3명, 전자상거래 플랫폼 개발 경험 5년, 자연어 처리 모델 구축 경험. 이전 프로젝트에서 10만 사용자 규모 서비스 운영.
                </div>
            </div>
        </div>

        <!-- Question 4 -->
        <div class="form-card" data-step="4">
            <div class="question-number">04</div>
            <h2 class="question-title">절대 원칙</h2>
            <p class="question-desc">이 제품 개발에서 절대 타협할 수 없는 원칙이나 가치는 무엇인가요?</p>
            
            <div class="input-group">
                <textarea id="principle" maxlength="100" placeholder="예: 사용자 프라이버시는..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="principleCount">0 / 100자</span>
                    <span id="principleStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    투명성과 정직함. 모든 리뷰는 실제 구매자만 작성 가능하며, 조작이나 가짜 리뷰는 절대 허용하지 않습니다.
                </div>
            </div>
        </div>

        <!-- Question 5 -->
        <div class="form-card" data-step="5">
            <div class="question-number">05</div>
            <h2 class="question-title">성공 정의</h2>
            <p class="question-desc">이 제품이 성공했다고 판단할 수 있는 기준은 무엇인가요? 구체적인 지표나 목표를 제시해주세요.</p>
            
            <div class="input-group">
                <textarea id="success" maxlength="100" placeholder="예: 6개월 내..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="successCount">0 / 100자</span>
                    <span id="successStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    6개월 내 월간 활성 사용자 5만명, 리뷰 신뢰도 평가 4.5/5 이상, 구매 전환율 기존 대비 30% 향상.
                </div>
            </div>
        </div>

        <!-- Question 6 -->
        <div class="form-card" data-step="6">
            <div class="question-number">06</div>
            <h2 class="question-title">핵심 기능 아이디어</h2>
            <p class="question-desc">이 문제를 해결하기 위한 핵심 기능이나 솔루션 아이디어를 간단히 설명해주세요.</p>
            
            <div class="input-group">
                <textarea id="feature" maxlength="150" placeholder="예: AI 기반..."></textarea>
                <div class="char-counter">
                    <span class="char-count" id="featureCount">0 / 150자</span>
                    <span id="featureStatus"></span>
                </div>
                <div class="example-text">
                    <div class="example-label">💡 예시</div>
                    AI 기반 리뷰 검증 시스템: 구매 이력 확인, 텍스트 분석으로 가짜 리뷰 탐지, 검증 배지 부여. 사용자는 신뢰도 점수를 실시간 확인 가능.
                </div>
            </div>
        </div>

        <!-- Completion Screen -->
        <div class="form-card completion-screen" id="completionScreen">
            <div class="completion-icon">✨</div>
            <h2 class="completion-title">입력 완료!</h2>
            <p class="completion-desc">
                모든 정보가 성공적으로 저장되었습니다.<br>
                이제 전문적인 BRD 문서를 생성할 준비가 되었습니다.
            </p>
            <button class="btn-primary" onclick="startBRDGeneration()">BRD 생성하기</button>
        </div>

        <!-- BRD 생성 화면 -->
        <div class="form-card document-screen" id="brdScreen">
            <div class="document-header">
                <h2 class="document-title">Business Requirements Document</h2>
                <span class="document-badge badge-generating" id="brdBadge">생성 중</span>
            </div>

            <!-- 생성 중 애니메이션 -->
            <div class="generating-animation" id="brdGenerating">
                <div class="spinner"></div>
                <div class="generating-text">BRD를 생성하고 있습니다...</div>
                <div class="generating-subtext">Claude AI가 프로젝트 데이터를 분석 중입니다</div>
            </div>

            <!-- 에러 메시지 -->
            <div class="error-message" id="brdError" style="display: none;">
                <h3>⚠️ 생성 오류</h3>
                <p id="brdErrorText"></p>
                <button class="btn-primary" onclick="retryBRDGeneration()">다시 시도</button>
            </div>

            <!-- 생성된 문서 내용 -->
            <div id="brdContentWrapper" style="display: none;">
                <div class="document-content" id="brdContent"></div>
                
                <div class="document-actions">
                    <button class="btn-success" onclick="approveBRD()">✓ 승인하고 PRD 생성</button>
                    <button class="btn-outline" onclick="regenerateBRD()">↻ 다시 생성</button>
                    <button class="btn-outline" onclick="copyBRD()">📋 복사</button>
                    <button class="btn-outline" onclick="exportBRDtoPDF()">📄 PDF 내보내기</button>
                </div>
            </div>
        </div>

        <!-- PRD 생성 화면 -->
        <div class="form-card document-screen" id="prdScreen">
            <div class="document-header">
                <h2 class="document-title">Product Requirements Document</h2>
                <span class="document-badge badge-generating" id="prdBadge">생성 중</span>
            </div>

            <div class="generating-animation" id="prdGenerating">
                <div class="spinner"></div>
                <div class="generating-text">PRD를 생성하고 있습니다...</div>
                <div class="generating-subtext">BRD를 기반으로 상세 요구사항을 작성 중입니다</div>
            </div>

            <div class="error-message" id="prdError" style="display: none;">
                <h3>⚠️ 생성 오류</h3>
                <p id="prdErrorText"></p>
                <button class="btn-primary" onclick="retryPRDGeneration()">다시 시도</button>
            </div>

            <div id="prdContentWrapper" style="display: none;">
                <div class="document-content" id="prdContent"></div>
                
                <div class="document-actions">
                    <button class="btn-success" onclick="approvePRD()">✓ 승인하고 TRD 생성</button>
                    <button class="btn-outline" onclick="regeneratePRD()">↻ 다시 생성</button>
                    <button class="btn-outline" onclick="copyPRD()">📋 복사</button>
                    <button class="btn-outline" onclick="exportPRDtoPDF()">📄 PDF 내보내기</button>
                    <button class="btn-outline" onclick="skipToComplete()">건너뛰기</button>
                </div>
            </div>
        </div>

        <!-- TRD 생성 화면 -->
        <div class="form-card document-screen" id="trdScreen">
            <div class="document-header">
                <h2 class="document-title">Technical Requirements Document</h2>
                <span class="document-badge badge-generating" id="trdBadge">생성 중</span>
            </div>

            <div class="generating-animation" id="trdGenerating">
                <div class="spinner"></div>
                <div class="generating-text">TRD를 생성하고 있습니다...</div>
                <div class="generating-subtext">기술 스펙과 아키텍처를 설계 중입니다</div>
            </div>

            <div class="error-message" id="trdError" style="display: none;">
                <h3>⚠️ 생성 오류</h3>
                <p id="trdErrorText"></p>
                <button class="btn-primary" onclick="retryTRDGeneration()">다시 시도</button>
            </div>

            <div id="trdContentWrapper" style="display: none;">
                <div class="document-content" id="trdContent"></div>
                
                <div class="document-actions">
                    <button class="btn-success" onclick="completeProject()">✓ 프로젝트 완료</button>
                    <button class="btn-outline" onclick="regenerateTRD()">↻ 다시 생성</button>
                    <button class="btn-outline" onclick="copyTRD()">📋 복사</button>
                    <button class="btn-outline" onclick="exportTRDtoPDF()">📄 PDF 내보내기</button>
                </div>
            </div>
        </div>

        <!-- 최종 완료 화면 -->
        <div class="form-card completion-screen" id="finalCompletionScreen">
            <div class="completion-icon">🎉</div>
            <h2 class="completion-title">모든 문서 생성 완료!</h2>
            <p class="completion-desc">
                BRD, PRD, TRD가 성공적으로 생성되었습니다.<br>
                모든 문서를 다운로드하거나 새 프로젝트를 시작할 수 있습니다.
            </p>
            <div class="document-actions" style="justify-content: center;">
                <button class="btn-primary" onclick="downloadAllDocuments()">📦 모든 문서 다운로드</button>
                <button class="btn-outline" onclick="startNewProject()">🔄 새 프로젝트 시작</button>
            </div>
        </div>

        <div class="button-group" id="navigationButtons">
            <button class="btn-secondary" id="prevBtn" onclick="prevStep()" style="display: none;">이전</button>
            <button class="btn-primary" id="nextBtn" onclick="nextStep()" disabled>다음</button>
        </div>

        <div class="auto-save-indicator" id="autoSaveIndicator">
            💾 자동 저장됨
        </div>
    </div>

    <script>
        // UUID 생성 함수
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // 프로젝트 데이터 구조
        class ProjectData {
            constructor() {
                this.id = generateUUID();
                this.created_at = new Date().toISOString();
                this.updated_at = new Date().toISOString();
                this.status = 'input';
                
                this.user_input = {
                    insight: '',
                    evidence: '',
                    capability: '',
                    principle: '',
                    success_metric: '',
                    core_features: ''
                };
                
                this.documents = {
                    brd: {
                        content: '',
                        status: 'pending',
                        generated_at: null,
                        version: 0
                    },
                    prd: {
                        content: '',
                        status: 'pending',
                        generated_at: null,
                        version: 0
                    },
                    trd: {
                        content: '',
                        status: 'pending',
                        generated_at: null,
                        version: 0
                    }
                };
                
                this.structured_data = {
                    personas: [],
                    features: [],
                    metrics: [],
                    technical_specs: []
                };

                this.history = [];
            }

            // 데이터 업데이트
            updateUserInput(field, value) {
                this.user_input[field] = value;
                this.updated_at = new Date().toISOString();
                this.addHistory('user_input_updated', { field, value });
                this.save();
            }

            // 상태 변경
            updateStatus(newStatus) {
                const oldStatus = this.status;
                this.status = newStatus;
                this.updated_at = new Date().toISOString();
                this.addHistory('status_changed', { from: oldStatus, to: newStatus });
                this.save();
            }

            // 문서 생성 시작
            startDocumentGeneration(docType) {
                this.documents[docType].status = 'generating';
                this.updated_at = new Date().toISOString();
                this.addHistory('document_generation_started', { type: docType });
                this.save();
            }

            // 문서 생성 완료
            completeDocumentGeneration(docType, content) {
                this.documents[docType].content = content;
                this.documents[docType].status = 'generated';
                this.documents[docType].generated_at = new Date().toISOString();
                this.documents[docType].version++;
                this.updated_at = new Date().toISOString();
                this.addHistory('document_generated', { type: docType, version: this.documents[docType].version });
                this.save();
            }

            // 문서 승인
            approveDocument(docType) {
                this.documents[docType].status = 'approved';
                this.updated_at = new Date().toISOString();
                this.addHistory('document_approved', { type: docType });
                this.save();
            }

            // 구조화된 데이터 추가
            addStructuredData(category, data) {
                this.structured_data[category].push({
                    id: generateUUID(),
                    ...data,
                    created_at: new Date().toISOString()
                });
                this.updated_at = new Date().toISOString();
                this.addHistory('structured_data_added', { category, data });
                this.save();
            }

            // 히스토리 추가
            addHistory(action, details) {
                this.history.push({
                    timestamp: new Date().toISOString(),
                    action,
                    details
                });
            }

            // 로컬 스토리지에 저장
            save() {
                try {
                    localStorage.setItem('projectData', JSON.stringify(this));
                    localStorage.setItem('projectData_backup_' + Date.now(), JSON.stringify(this));
                    console.log('✅ 프로젝트 데이터 저장 완료:', this.id);
                    return true;
                } catch (e) {
                    console.error('❌ 저장 실패:', e);
                    return false;
                }
            }

            // 로컬 스토리지에서 불러오기
            static load() {
                try {
                    const saved = localStorage.getItem('projectData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        const project = new ProjectData();
                        Object.assign(project, data);
                        console.log('✅ 프로젝트 데이터 로드 완료:', project.id);
                        return project;
                    }
                } catch (e) {
                    console.error('❌ 로드 실패:', e);
                }
                return new ProjectData();
            }

            // 진행률 계산
            getProgress() {
                const fields = Object.values(this.user_input);
                const completed = fields.filter(v => v && v.trim().length > 0).length;
                return {
                    completed,
                    total: fields.length,
                    percentage: Math.round((completed / fields.length) * 100)
                };
            }

            // 입력 완료 여부 확인
            isInputComplete() {
                return Object.values(this.user_input).every(v => v && v.trim().length > 0);
            }

            // 데이터 내보내기 (JSON)
            exportJSON() {
                return JSON.stringify(this, null, 2);
            }

            // 데이터 요약
            getSummary() {
                const progress = this.getProgress();
                return {
                    id: this.id,
                    created: new Date(this.created_at).toLocaleString('ko-KR'),
                    updated: new Date(this.updated_at).toLocaleString('ko-KR'),
                    status: this.status,
                    progress: `${progress.completed}/${progress.total} (${progress.percentage}%)`,
                    documents: {
                        brd: this.documents.brd.status,
                        prd: this.documents.prd.status,
                        trd: this.documents.trd.status
                    }
                };
            }
        }

        // 전역 프로젝트 인스턴스
        let projectData = ProjectData.load();

        // 상태 관리
        let currentStep = 1;
        const totalSteps = 6;
        
        // 필드 매핑 (화면 ID -> 데이터 구조)
        const fieldMapping = {
            insight: 'insight',
            validation: 'evidence',
            capability: 'capability',
            principle: 'principle',
            success: 'success_metric',
            feature: 'core_features'
        };

        // 로컬 스토리지에서 데이터 불러오기
        function loadSavedData() {
            // 프로젝트 데이터에서 사용자 입력 불러오기
            Object.keys(fieldMapping).forEach(fieldId => {
                const dataKey = fieldMapping[fieldId];
                const element = document.getElementById(fieldId);
                if (element && projectData.user_input[dataKey]) {
                    element.value = projectData.user_input[dataKey];
                    updateCharCount(fieldId);
                }
            });

            console.log('📊 프로젝트 요약:', projectData.getSummary());
        }

        // 자동 저장
        function autoSave() {
            const saved = projectData.save();
            if (saved) {
                showAutoSaveIndicator();
            }
        }

        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        // 글자수 카운터 업데이트
        function updateCharCount(fieldId) {
            const textarea = document.getElementById(fieldId);
            const counter = document.getElementById(fieldId + 'Count');
            const status = document.getElementById(fieldId + 'Status');
            const maxLength = textarea.maxLength;
            const currentLength = textarea.value.length;
            
            counter.textContent = `${currentLength} / ${maxLength}자`;
            
            if (currentLength > maxLength * 0.9) {
                counter.classList.add('warning');
            } else {
                counter.classList.remove('warning');
            }

            // 유효성 검사
            if (currentLength > 0) {
                status.textContent = '✓';
                status.style.color = '#a89075';
                textarea.classList.remove('error');
            } else {
                status.textContent = '';
                textarea.classList.add('error');
            }

            // 프로젝트 데이터에 저장
            const dataKey = fieldMapping[fieldId];
            projectData.updateUserInput(dataKey, textarea.value);

            // 다음 버튼 활성화/비활성화
            updateNextButton();
        }

        // 다음 버튼 상태 업데이트
        function updateNextButton() {
            const nextBtn = document.getElementById('nextBtn');
            const currentFieldId = getCurrentFieldId();
            const textarea = document.getElementById(currentFieldId);
            const currentValue = textarea ? textarea.value : '';
            
            if (currentValue && currentValue.trim().length > 0) {
                nextBtn.disabled = false;
            } else {
                nextBtn.disabled = true;
            }
        }

        // 현재 필드 ID 가져오기
        function getCurrentFieldId() {
            const fields = ['insight', 'validation', 'capability', 'principle', 'success', 'feature'];
            return fields[currentStep - 1];
        }

        // 진행률 업데이트
        function updateProgress() {
            const progress = projectData.getProgress();
            const displayProgress = ((currentStep - 1) / totalSteps) * 100;
            
            document.getElementById('progressFill').style.width = displayProgress + '%';
            document.getElementById('progressText').textContent = `질문 ${currentStep} / ${totalSteps}`;
            document.getElementById('progressPercent').textContent = `${progress.percentage}% 완료`;
        }

        // 다음 단계
        function nextStep() {
            if (currentStep < totalSteps) {
                // 현재 카드 숨기기
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.remove('active');
                
                currentStep++;
                
                // 다음 카드 보이기
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.add('active');
                
                updateProgress();
                updateNextButton();
                
                // 버튼 표시 조정
                document.getElementById('prevBtn').style.display = 'block';
                
                if (currentStep === totalSteps) {
                    document.getElementById('nextBtn').textContent = '완료';
                }
                
                // 스크롤 맨 위로
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
                showCompletion();
            }
        }

        // 이전 단계
        function prevStep() {
            if (currentStep > 1) {
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.remove('active');
                
                currentStep--;
                
                document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.add('active');
                
                updateProgress();
                updateNextButton();
                
                if (currentStep === 1) {
                    document.getElementById('prevBtn').style.display = 'none';
                }
                
                document.getElementById('nextBtn').textContent = '다음';
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // 완료 화면 표시
        function showCompletion() {
            document.querySelector(`.form-card[data-step="${currentStep}"]`).classList.remove('active');
            document.getElementById('completionScreen').classList.add('active');
            document.getElementById('navigationButtons').style.display = 'none';
            
            // 상태 업데이트
            projectData.updateStatus('input_completed');
            
            // 진행률 100%
            document.getElementById('progressFill').style.width = '100%';
            document.getElementById('progressText').textContent = '완료!';
            document.getElementById('progressPercent').textContent = '100% 완료';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });

            console.log('🎉 입력 완료! 프로젝트 데이터:', projectData.getSummary());
        }

        // 문서 생성 (다음 단계로 연결될 함수)
        function generateDocuments() {
            startBRDGeneration();
        }

        // 워크플로우 상태 업데이트
        function updateWorkflowStatus(currentStage) {
            const stages = ['input', 'brd', 'prd', 'trd'];
            const stageElements = document.querySelectorAll('.workflow-step');
            
            stages.forEach((stage, index) => {
                const element = document.querySelector(`.workflow-step[data-step="${stage}"]`);
                
                if (stage === currentStage) {
                    element.classList.add('active');
                    element.classList.remove('completed');
                } else if (stages.indexOf(currentStage) > index) {
                    element.classList.add('completed');
                    element.classList.remove('active');
                } else {
                    element.classList.remove('active', 'completed');
                }
            });
        }

        // BRD 생성 시작
        async function startBRDGeneration() {
            // 화면 전환
            document.getElementById('completionScreen').classList.remove('active');
            document.getElementById('brdScreen').classList.add('active');
            document.getElementById('navigationButtons').style.display = 'none';
            
            // 상태 업데이트
            projectData.updateStatus('brd_generating');
            projectData.startDocumentGeneration('brd');
            updateWorkflowStatus('brd');
            
            // 생성 시작
            await generateBRD();
        }

        // BRD 생성 API 호출 (AI 프롬프트 기반)
        async function generateBRD() {
            try {
                // AI 프롬프트 생성
                const prompt = createBRDPrompt();
                
                // 실제 AI API 호출 (현재는 데모 모드)
                const brdContent = await callAIAPI(prompt, 'BRD');

                // BRD 저장 및 표시
                projectData.completeDocumentGeneration('brd', brdContent);
                displayBRD(brdContent);

            } catch (error) {
                console.error('BRD 생성 오류:', error);
                showBRDError(error.message);
            }
        }

        // BRD 프롬프트 생성
        function createBRDPrompt() {
            const input = projectData.user_input;
            return `당신은 제품 전략 및 비즈니스 분석 전문가입니다. 다음 정보를 바탕으로 전문적인 Business Requirements Document(BRD)를 작성해주세요.

**사용자 입력 데이터:**

**핵심 인사이트:**
${input.insight}

**검증 근거:**
${input.evidence}

**팀 역량:**
${input.capability}

**절대 원칙:**
${input.principle}

**성공 정의:**
${input.success_metric}

**핵심 기능 아이디어:**
${input.core_features}

---

**BRD 작성 가이드라인:**

다음 구조로 전문적이고 상세한 BRD를 작성해주세요:

## 1. Executive Summary
- 프로젝트 개요 (2-3 문단)
- 핵심 비즈니스 가치
- 예상 ROI 및 영향

## 2. Business Objectives
- 구체적인 비즈니스 목표 (3-5개)
- 각 목표의 측정 가능한 지표
- 목표 달성 타임라인

## 3. Market Analysis
- 시장 기회 분석
- 타겟 고객 페르소나
- 경쟁사 분석

## 4. Problem Statement
- 해결하려는 핵심 문제
- 문제의 비즈니스 영향
- 현재 상황 (As-Is)

## 5. Proposed Solution
- 솔루션 개요
- 핵심 기능 및 가치 제안
- 기대되는 결과 (To-Be)

## 6. Success Criteria
- 정량적 KPI (3-5개)
- 정성적 성공 지표
- 측정 방법

## 7. Stakeholders
- 주요 이해관계자
- 각 이해관계자의 역할
- 의사결정 프로세스

## 8. Constraints & Risks
- 제약 사항 (시간, 예산, 기술, 리소스)
- 주요 리스크 및 완화 방안
- 의존성

## 9. Timeline & Milestones
- 주요 마일스톤
- 단계별 일정
- 출시 계획

## 10. Budget & Resources
- 예산 추정
- 필요 리소스
- 투자 대비 기대 효과

**중요:**
- 각 섹션은 구체적이고 실행 가능해야 합니다
- 비즈니스 가치와 ROI를 명확히 제시하세요
- 데이터 기반의 의사결정을 강조하세요
- 전문적이고 설득력 있는 문체를 사용하세요
- 마크다운 형식으로 작성하세요`;
        }

        // AI API 호출 함수 (현재는 데모 모드)
        async function callAIAPI(prompt, docType) {
            try {
                // 실제 AI API 호출 (Claude API 예시)
                /*
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "x-api-key": "YOUR_API_KEY"
                    },
                    body: JSON.stringify({
                        model: "claude-3-sonnet-20240229",
                        max_tokens: 4000,
                        messages: [{ role: "user", content: prompt }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API 오류: ${response.status}`);
                }
                
                const data = await response.json();
                return data.content[0].text;
                */
                
                // 데모 모드: 프롬프트 기반 시뮬레이션
                console.log(`🤖 ${docType} AI 프롬프트 생성됨:`, prompt.substring(0, 200) + '...');
                
                // 3초 대기 (로딩 효과)
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // 데모 응답 생성
                return generateDemoResponse(docType, prompt);
                
            } catch (error) {
                console.error(`${docType} AI API 호출 오류:`, error);
                throw error;
            }
        }

        // 데모 응답 생성
        function generateDemoResponse(docType, prompt) {
            const input = projectData.user_input;
            
            if (docType === 'BRD') {
                return `# Business Requirements Document

## 1. Executive Summary
이 프로젝트는 "${input.insight || '사용자 정의 핵심 인사이트'}"를 해결하기 위한 비즈니스 솔루션입니다. ${input.evidence ? `검증된 근거에 따르면 ${input.evidence}이며,` : ''} 이를 통해 시장에서의 경쟁 우위를 확보하고 비즈니스 가치를 창출하는 것을 목표로 합니다.

## 2. Business Objectives
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표 달성'}
- 시장 점유율 확대
- 고객 만족도 향상
- 수익성 증대

## 3. Market Analysis
**시장 기회:**
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결할 수 있는 시장 기회가 존재합니다.

**타겟 고객:**
- 주요 고객층: 문제를 겪고 있는 사용자
- 고객 니즈: 핵심 문제 해결
- 시장 규모: 성장 잠재력 분석

## 4. Problem Statement
**핵심 문제:**
${input.insight ? `"${input.insight}"` : '사용자가 식별한 핵심 문제'}

**비즈니스 영향:**
- 현재 상황에서의 손실 및 기회비용
- 문제 지속 시 예상되는 부정적 영향
- 시급성 및 중요성

## 5. Proposed Solution
**솔루션 개요:**
${input.core_features ? `핵심 기능: ${input.core_features}` : '사용자 정의 핵심 기능을 기반으로 한 솔루션'}

**가치 제안:**
- 사용자 문제 해결
- 비즈니스 가치 창출
- 경쟁 우위 확보

## 6. Success Criteria
**정량적 KPI:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**정성적 지표:**
- 사용자 만족도 향상
- 시장 인지도 증대
- 브랜드 가치 상승

## 7. Stakeholders
**주요 이해관계자:**
- 프로젝트 스폰서
- 개발팀
- 사용자/고객
- 비즈니스 파트너

## 8. Constraints & Risks
**제약 사항:**
${input.principle ? `절대 원칙: ${input.principle}` : '사용자 정의 제약 사항'}

**주요 리스크:**
- 기술적 복잡성
- 시장 변화
- 자원 제약

## 9. Timeline & Milestones
**개발 단계:**
- Phase 1: 기획 및 설계 (1-2개월)
- Phase 2: 개발 및 테스트 (2-3개월)
- Phase 3: 출시 및 운영 (1개월)

## 10. Budget & Resources
**필요 리소스:**
${input.capability ? `팀 역량: ${input.capability}` : '사용자 팀의 역량을 기반으로 한 리소스 계획'}

**예산 추정:**
- 개발비: 팀 규모 및 기간에 따라 산정
- 마케팅비: 시장 진입 전략
- 운영비: 지속적 서비스 운영

---

*이 문서는 AI가 사용자 입력 데이터를 바탕으로 생성했습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
            }
            
            if (docType === 'PRD') {
                return `# Product Requirements Document

## 1. Product Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 제품입니다. ${input.core_features ? `핵심 기능으로는 ${input.core_features}가 있습니다.` : '사용자가 정의한 핵심 기능을 포함합니다.'}

## 2. User Personas
**주요 사용자:**
- 타겟 고객: 사용자 입력 기반 정의
- 사용자 니즈: ${input.insight ? `"${input.insight}"` : '핵심 문제 해결'}
- 사용 패턴: 예상 사용 시나리오

## 3. Feature Requirements
**핵심 기능:**
${input.core_features ? `- ${input.core_features}` : '- 사용자 정의 핵심 기능'}

**우선순위:**
- P0: 핵심 문제 해결 기능
- P1: 사용자 경험 향상 기능
- P2: 부가 가치 기능

## 4. User Stories
**사용자 시나리오:**
- 사용자는 ${input.insight ? `"${input.insight}"` : '핵심 문제'}를 해결할 수 있다
- 사용자는 ${input.core_features ? `"${input.core_features}"` : '핵심 기능'}을 활용할 수 있다
- 사용자는 ${input.success_metric ? `"${input.success_metric}"` : '성공 지표'}를 달성할 수 있다

## 5. User Experience
**사용자 경험 설계:**
- 직관적인 인터페이스
- ${input.principle ? `"${input.principle}"` : '사용자 원칙'} 준수
- 효율적인 워크플로우

## 6. Functional Requirements
**기능적 요구사항:**
- 핵심 기능 구현
- 데이터 처리 및 분석
- 사용자 인터랙션
- 결과 제공 및 피드백

## 7. Non-Functional Requirements
**성능 요구사항:**
- 응답 시간: 3초 이내
- 가용성: 99% 이상
- 확장성: 사용자 증가 대응
- 보안: 데이터 보호

## 8. Data Requirements
**데이터 요구사항:**
- 사용자 입력 데이터
- 처리 결과 데이터
- 분석 데이터
- 히스토리 데이터

## 9. Integration Requirements
**연동 요구사항:**
- 외부 시스템 연동
- API 연동
- 데이터 동기화
- 실시간 처리

## 10. Success Metrics
**성공 지표:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**측정 방법:**
- 사용자 피드백
- 사용량 분석
- 성과 측정
- 지속적 개선

---

*이 문서는 AI가 사용자 입력 데이터를 바탕으로 생성했습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
            }
            
            if (docType === 'TRD') {
                return `# Technical Requirements Document

## 1. Technical Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 기술적 솔루션입니다. ${input.capability ? `팀의 역량인 ${input.capability}을 활용하여 구현합니다.` : '사용자 팀의 역량을 기반으로 구현합니다.'}

## 2. System Architecture
**전체 아키텍처:**
- **Frontend**: 사용자 인터페이스
- **Backend**: 비즈니스 로직 처리
- **Database**: 데이터 저장 및 관리
- **Integration**: 외부 시스템 연동

## 3. Technology Stack
**기술 스택 선택 기준:**
${input.capability ? `- 팀 역량: ${input.capability}` : '- 팀 역량 기반 기술 선택'}

**권장 기술:**
- **Frontend**: React.js, Vue.js, Angular
- **Backend**: Node.js, Python, Java
- **Database**: PostgreSQL, MySQL, MongoDB
- **Infrastructure**: Docker, Kubernetes

## 4. Data Architecture
**데이터 설계:**
- **사용자 데이터**: 프로필 및 설정
- **비즈니스 데이터**: 핵심 비즈니스 로직
- **분석 데이터**: 성과 및 지표
- **로그 데이터**: 시스템 모니터링

## 5. API Design
**API 설계 원칙:**
- **RESTful API**: 표준 HTTP 메서드
- **인증**: JWT 또는 OAuth 2.0
- **Rate Limiting**: 서비스 보호
- **버전 관리**: API 호환성

## 6. Security Requirements
**보안 요구사항:**
${input.principle ? `- ${input.principle} 준수` : '- 사용자 정의 보안 원칙'}

**보안 구현:**
- **인증**: 사용자 인증 시스템
- **암호화**: 데이터 암호화
- **HTTPS**: 통신 보안
- **데이터 보호**: 개인정보 보호

## 7. Performance Requirements
**성능 목표:**
${input.success_metric ? `- ${input.success_metric} 달성을 위한 성능 최적화` : '- 사용자 정의 성공 지표 달성'}

**성능 지표:**
- **응답 시간**: 3초 이내
- **처리량**: 예상 사용자 수 대응
- **가용성**: 99% 이상
- **확장성**: 사용자 증가 대응

## 8. Scalability & Availability
**확장성 설계:**
- **로드 밸런싱**: 트래픽 분산
- **자동 스케일링**: 리소스 자동 조정
- **장애 복구**: 고가용성 보장
- **모니터링**: 실시간 상태 확인

## 9. Development Guidelines
**개발 가이드라인:**
- **코딩 컨벤션**: 팀 표준 준수
- **Git 워크플로우**: 협업 프로세스
- **테스팅**: 품질 보증
- **CI/CD**: 자동화된 배포

## 10. Implementation Roadmap
**구현 계획:**
- **Phase 1**: 기본 인프라 구축 (1-2개월)
- **Phase 2**: 핵심 기능 개발 (2-3개월)
- **Phase 3**: 통합 및 테스트 (1개월)
- **Phase 4**: 출시 및 운영 (지속적)

---

*이 문서는 AI가 사용자 입력 데이터를 바탕으로 생성했습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
            }
        }

        // 사용자 입력 기반 BRD 내용 생성
        function createBRDContent(input) {
            return `# Business Requirements Document

## 1. Executive Summary
${input.insight ? `이 프로젝트는 "${input.insight}"라는 핵심 인사이트를 바탕으로 시작되었습니다.` : '이 프로젝트는 사용자의 핵심 인사이트를 바탕으로 시작되었습니다.'} ${input.evidence ? `검증된 근거에 따르면 ${input.evidence}입니다.` : '사용자가 제공한 검증 근거를 바탕으로 합니다.'} 이를 통해 비즈니스 가치를 창출하고 시장에서의 경쟁 우위를 확보하는 것을 목표로 합니다.

## 2. Business Objectives
${input.success_metric ? `- ${input.success_metric}` : '- 구체적인 성공 지표를 달성'}

**핵심 목표:**
- 사용자 입력 기반 비즈니스 목표 달성
- 시장에서의 경쟁 우위 확보
- 지속 가능한 성장 모델 구축

## 3. Market Analysis
**시장 기회:**
${input.insight ? `현재 시장에서 "${input.insight}"라는 문제가 존재하며, 이를 해결할 수 있는 기회가 있습니다.` : '사용자가 식별한 시장 기회를 분석합니다.'}

**타겟 고객:**
- 주요 고객층: 사용자 입력 기반 정의
- 고객 니즈: 핵심 문제 해결
- 시장 규모: 성장 잠재력 분석

## 4. Problem Statement
**핵심 문제:**
${input.insight ? `"${input.insight}"` : '사용자가 식별한 핵심 문제'}

**비즈니스 영향:**
- 현재 상황에서의 손실 및 기회비용
- 문제 지속 시 예상되는 부정적 영향
- 시급성 및 중요성

## 5. Proposed Solution
**솔루션 개요:**
${input.core_features ? `핵심 기능: ${input.core_features}` : '사용자가 제안한 핵심 기능을 기반으로 한 솔루션'}

**가치 제안:**
- 사용자 문제 해결
- 비즈니스 가치 창출
- 경쟁 우위 확보

## 6. Success Criteria
**정량적 KPI:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**정성적 지표:**
- 사용자 만족도 향상
- 시장 인지도 증대
- 브랜드 가치 상승

## 7. Stakeholders
**주요 이해관계자:**
- 프로젝트 스폰서
- 개발팀
- 사용자/고객
- 비즈니스 파트너

**역할 및 책임:**
- 의사결정권자: 전략적 방향 설정
- 실행팀: 구체적 구현
- 사용자: 피드백 및 검증

## 8. Constraints & Risks
**제약 사항:**
${input.principle ? `절대 원칙: ${input.principle}` : '사용자 정의 제약 사항'}

**주요 리스크:**
- 기술적 복잡성
- 시장 변화
- 자원 제약

**완화 방안:**
- 단계적 접근
- 지속적 모니터링
- 유연한 대응

## 9. Timeline & Milestones
**개발 단계:**
- Phase 1: 기획 및 설계 (1-2개월)
- Phase 2: 개발 및 테스트 (2-3개월)
- Phase 3: 출시 및 운영 (1개월)

**주요 마일스톤:**
- MVP 출시
- 베타 테스트 완료
- 정식 출시

## 10. Budget & Resources
**필요 리소스:**
${input.capability ? `팀 역량: ${input.capability}` : '사용자 팀의 역량을 기반으로 한 리소스 계획'}

**예산 추정:**
- 개발비: 팀 규모 및 기간에 따라 산정
- 마케팅비: 시장 진입 전략
- 운영비: 지속적 서비스 운영

**투자 대비 효과:**
- ROI 예상치
- 비용 절감 효과
- 수익 창출 잠재력

---

*이 문서는 사용자 입력 데이터를 바탕으로 생성되었습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
        }

        // BRD 표시
        function displayBRD(content) {
            document.getElementById('brdGenerating').style.display = 'none';
            document.getElementById('brdContentWrapper').style.display = 'block';
            document.getElementById('brdContent').innerHTML = convertMarkdownToHTML(content);
            document.getElementById('brdBadge').textContent = '생성 완료';
            document.getElementById('brdBadge').className = 'document-badge badge-generated';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // BRD 오류 표시
        function showBRDError(errorMessage) {
            document.getElementById('brdGenerating').style.display = 'none';
            document.getElementById('brdError').style.display = 'block';
            document.getElementById('brdErrorText').textContent = errorMessage;
        }

        // BRD 재생성
        async function regenerateBRD() {
            document.getElementById('brdContentWrapper').style.display = 'none';
            document.getElementById('brdGenerating').style.display = 'block';
            document.getElementById('brdBadge').textContent = '생성 중';
            document.getElementById('brdBadge').className = 'document-badge badge-generating';
            
            await generateBRD();
        }

        // BRD 재시도
        async function retryBRDGeneration() {
            document.getElementById('brdError').style.display = 'none';
            document.getElementById('brdGenerating').style.display = 'block';
            
            await generateBRD();
        }

        // BRD 승인 및 PRD 생성
        async function approveBRD() {
            projectData.approveDocument('brd');
            projectData.updateStatus('prd_generating');
            updateWorkflowStatus('prd');
            
            // PRD 화면으로 전환
            document.getElementById('brdScreen').classList.remove('active');
            document.getElementById('prdScreen').classList.add('active');
            
            document.getElementById('brdBadge').textContent = '승인됨';
            document.getElementById('brdBadge').className = 'document-badge badge-approved';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // PRD 생성 시작
            await generatePRD();
        }

        // PRD 생성
        async function generatePRD() {
            try {
                // AI 프롬프트 생성
                const prompt = createPRDPrompt();
                
                // 실제 AI API 호출 (현재는 데모 모드)
                const prdContent = await callAIAPI(prompt, 'PRD');

                projectData.completeDocumentGeneration('prd', prdContent);
                displayPRD(prdContent);

            } catch (error) {
                console.error('PRD 생성 오류:', error);
                showPRDError(error.message);
            }
        }

        // PRD 프롬프트 생성
        function createPRDPrompt() {
            const input = projectData.user_input;
            const brd = projectData.documents.brd.content;
            return `당신은 제품 관리 및 요구사항 분석 전문가입니다. 아래의 BRD와 사용자 입력을 바탕으로 상세한 Product Requirements Document(PRD)를 작성해주세요.

**BRD:**
${brd}

**원본 사용자 입력:**
- 핵심 인사이트: ${input.insight}
- 검증 근거: ${input.evidence}
- 팀 역량: ${input.capability}
- 절대 원칙: ${input.principle}
- 성공 정의: ${input.success_metric}
- 핵심 기능: ${input.core_features}

---

**PRD 작성 가이드라인:**

## 1. Product Overview
- 제품 비전
- 제품 목표
- 타겟 사용자

## 2. User Personas
- 주요 페르소나 (3-4개)
- 각 페르소나의 니즈와 페인 포인트
- 사용 시나리오

## 3. Feature Requirements
각 기능마다 다음을 포함:
- 기능 이름 및 설명
- 우선순위 (P0/P1/P2)
- 사용자 스토리
- 인수 기준
- 의존성

## 4. User Stories
- Epic별 사용자 스토리
- 스토리 포인트
- Definition of Done

## 5. User Experience
- 주요 사용자 플로우
- 화면 구성 및 레이아웃
- 인터랙션 설계

## 6. Functional Requirements
- 상세 기능 명세
- 입력/출력 정의
- 비즈니스 규칙

## 7. Non-Functional Requirements
- 성능 요구사항
- 보안 요구사항
- 확장성 및 가용성
- 접근성

## 8. Data Requirements
- 데이터 모델
- 데이터 플로우
- 저장소 요구사항

## 9. Integration Requirements
- 외부 시스템 연동
- API 명세
- 데이터 동기화

## 10. Success Metrics
- 기능별 성공 지표
- 측정 방법
- 목표값

**중요:**
- 개발팀이 바로 구현할 수 있을 만큼 구체적으로 작성하세요
- 각 요구사항은 명확하고 검증 가능해야 합니다
- 우선순위를 명확히 하세요
- 마크다운 형식으로 작성하세요`;
        }

        // 사용자 입력 기반 PRD 내용 생성
        function createPRDContent(input) {
            return `# Product Requirements Document

## 1. Product Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 제품입니다. ${input.core_features ? `핵심 기능으로는 ${input.core_features}가 있습니다.` : '사용자가 정의한 핵심 기능을 포함합니다.'}

## 2. User Personas
**주요 사용자:**
- 타겟 고객: 사용자 입력 기반 정의
- 사용자 니즈: ${input.insight ? `"${input.insight}"` : '핵심 문제 해결'}
- 사용 패턴: 예상 사용 시나리오

## 3. Feature Requirements
**핵심 기능:**
${input.core_features ? `- ${input.core_features}` : '- 사용자 정의 핵심 기능'}

**우선순위:**
- P0: 핵심 문제 해결 기능
- P1: 사용자 경험 향상 기능
- P2: 부가 가치 기능

## 4. User Stories
**사용자 시나리오:**
- 사용자는 ${input.insight ? `"${input.insight}"` : '핵심 문제'}를 해결할 수 있다
- 사용자는 ${input.core_features ? `"${input.core_features}"` : '핵심 기능'}을 활용할 수 있다
- 사용자는 ${input.success_metric ? `"${input.success_metric}"` : '성공 지표'}를 달성할 수 있다

## 5. User Experience
**사용자 경험 설계:**
- 직관적인 인터페이스
- ${input.principle ? `"${input.principle}"` : '사용자 원칙'} 준수
- 효율적인 워크플로우

## 6. Functional Requirements
**기능적 요구사항:**
- 핵심 기능 구현
- 데이터 처리 및 분석
- 사용자 인터랙션
- 결과 제공 및 피드백

## 7. Non-Functional Requirements
**성능 요구사항:**
- 응답 시간: 3초 이내
- 가용성: 99% 이상
- 확장성: 사용자 증가 대응
- 보안: 데이터 보호

## 8. Data Requirements
**데이터 요구사항:**
- 사용자 입력 데이터
- 처리 결과 데이터
- 분석 데이터
- 히스토리 데이터

## 9. Integration Requirements
**연동 요구사항:**
- 외부 시스템 연동
- API 연동
- 데이터 동기화
- 실시간 처리

## 10. Success Metrics
**성공 지표:**
${input.success_metric ? `- ${input.success_metric}` : '- 사용자 정의 성공 지표'}

**측정 방법:**
- 사용자 피드백
- 사용량 분석
- 성과 측정
- 지속적 개선

---

*이 문서는 사용자 입력 데이터를 바탕으로 생성되었습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
        }

        // PRD 표시
        function displayPRD(content) {
            document.getElementById('prdGenerating').style.display = 'none';
            document.getElementById('prdContentWrapper').style.display = 'block';
            document.getElementById('prdContent').innerHTML = convertMarkdownToHTML(content);
            document.getElementById('prdBadge').textContent = '생성 완료';
            document.getElementById('prdBadge').className = 'document-badge badge-generated';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // PRD 오류 표시
        function showPRDError(errorMessage) {
            document.getElementById('prdGenerating').style.display = 'none';
            document.getElementById('prdError').style.display = 'block';
            document.getElementById('prdErrorText').textContent = errorMessage;
        }

        // PRD 재생성
        async function regeneratePRD() {
            document.getElementById('prdContentWrapper').style.display = 'none';
            document.getElementById('prdGenerating').style.display = 'block';
            document.getElementById('prdBadge').textContent = '생성 중';
            document.getElementById('prdBadge').className = 'document-badge badge-generating';
            
            await generatePRD();
        }

        // PRD 재시도
        async function retryPRDGeneration() {
            document.getElementById('prdError').style.display = 'none';
            document.getElementById('prdGenerating').style.display = 'block';
            
            await generatePRD();
        }

        // PRD 승인 및 TRD 생성
        async function approvePRD() {
            projectData.approveDocument('prd');
            projectData.updateStatus('trd_generating');
            updateWorkflowStatus('trd');
            
            document.getElementById('prdScreen').classList.remove('active');
            document.getElementById('trdScreen').classList.add('active');
            
            document.getElementById('prdBadge').textContent = '승인됨';
            document.getElementById('prdBadge').className = 'document-badge badge-approved';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            await generateTRD();
        }

        // TRD 생성
        async function generateTRD() {
            try {
                // AI 프롬프트 생성
                const prompt = createTRDPrompt();
                
                // 실제 AI API 호출 (현재는 데모 모드)
                const trdContent = await callAIAPI(prompt, 'TRD');

                projectData.completeDocumentGeneration('trd', trdContent);
                displayTRD(trdContent);

            } catch (error) {
                console.error('TRD 생성 오류:', error);
                showTRDError(error.message);
            }
        }

        // TRD 프롬프트 생성
        function createTRDPrompt() {
            const input = projectData.user_input;
            const brd = projectData.documents.brd.content;
            const prd = projectData.documents.prd.content;
            return `당신은 소프트웨어 아키텍트 및 기술 설계 전문가입니다. BRD와 PRD를 바탕으로 Technical Requirements Document(TRD)를 작성해주세요.

**BRD 요약:**
${brd.substring(0, 1000)}...

**PRD 요약:**
${prd.substring(0, 1000)}...

**팀 역량:**
${input.capability}

---

**TRD 작성 가이드라인:**

## 1. Technical Overview
- 기술 비전
- 아키텍처 원칙
- 기술 스택 선정 이유

## 2. System Architecture
- 전체 시스템 아키텍처
- 주요 컴포넌트
- 데이터 플로우

## 3. Technology Stack
- Frontend 기술
- Backend 기술
- 데이터베이스
- 인프라 및 DevOps
- 외부 서비스

## 4. Data Architecture
- 데이터베이스 스키마
- 데이터 모델링
- 캐싱 전략
- 백업 및 복구

## 5. API Design
- RESTful API 설계
- 인증/인가
- Rate limiting
- API 버전 관리

## 6. Security Requirements
- 인증 및 권한
- 데이터 암호화
- 보안 취약점 대응
- 컴플라이언스

## 7. Performance Requirements
- 응답 시간 목표
- 처리량 목표
- 동시 사용자 수
- 최적화 전략

## 8. Scalability & Availability
- 확장성 설계
- 로드 밸런싱
- 장애 복구
- 모니터링

## 9. Development Guidelines
- 코딩 컨벤션
- Git 워크플로우
- 테스팅 전략
- CI/CD 파이프라인

## 10. Implementation Roadmap
- Phase별 기술 구현 계획
- 마일스톤
- 기술 부채 관리

**중요:**
- 실제 구현 가능한 구체적인 기술 스펙을 제시하세요
- 팀의 역량을 고려한 현실적인 기술 선택을 하세요
- 확장성과 유지보수성을 고려하세요
- 마크다운 형식으로 작성하세요`;
        }

        // 사용자 입력 기반 TRD 내용 생성
        function createTRDContent(input) {
            return `# Technical Requirements Document

## 1. Technical Overview
${input.insight ? `"${input.insight}"` : '사용자 정의 핵심 인사이트'}를 해결하기 위한 기술적 솔루션입니다. ${input.capability ? `팀의 역량인 ${input.capability}을 활용하여 구현합니다.` : '사용자 팀의 역량을 기반으로 구현합니다.'}

## 2. System Architecture
**전체 아키텍처:**
- **Frontend**: 사용자 인터페이스
- **Backend**: 비즈니스 로직 처리
- **Database**: 데이터 저장 및 관리
- **Integration**: 외부 시스템 연동

## 3. Technology Stack
**기술 스택 선택 기준:**
${input.capability ? `- 팀 역량: ${input.capability}` : '- 팀 역량 기반 기술 선택'}

**권장 기술:**
- **Frontend**: React.js, Vue.js, Angular
- **Backend**: Node.js, Python, Java
- **Database**: PostgreSQL, MySQL, MongoDB
- **Infrastructure**: Docker, Kubernetes

## 4. Data Architecture
**데이터 설계:**
- **사용자 데이터**: 프로필 및 설정
- **비즈니스 데이터**: 핵심 비즈니스 로직
- **분석 데이터**: 성과 및 지표
- **로그 데이터**: 시스템 모니터링

## 5. API Design
**API 설계 원칙:**
- **RESTful API**: 표준 HTTP 메서드
- **인증**: JWT 또는 OAuth 2.0
- **Rate Limiting**: 서비스 보호
- **버전 관리**: API 호환성

## 6. Security Requirements
**보안 요구사항:**
${input.principle ? `- ${input.principle} 준수` : '- 사용자 정의 보안 원칙'}

**보안 구현:**
- **인증**: 사용자 인증 시스템
- **암호화**: 데이터 암호화
- **HTTPS**: 통신 보안
- **데이터 보호**: 개인정보 보호

## 7. Performance Requirements
**성능 목표:**
${input.success_metric ? `- ${input.success_metric} 달성을 위한 성능 최적화` : '- 사용자 정의 성공 지표 달성'}

**성능 지표:**
- **응답 시간**: 3초 이내
- **처리량**: 예상 사용자 수 대응
- **가용성**: 99% 이상
- **확장성**: 사용자 증가 대응

## 8. Scalability & Availability
**확장성 설계:**
- **로드 밸런싱**: 트래픽 분산
- **자동 스케일링**: 리소스 자동 조정
- **장애 복구**: 고가용성 보장
- **모니터링**: 실시간 상태 확인

## 9. Development Guidelines
**개발 가이드라인:**
- **코딩 컨벤션**: 팀 표준 준수
- **Git 워크플로우**: 협업 프로세스
- **테스팅**: 품질 보증
- **CI/CD**: 자동화된 배포

## 10. Implementation Roadmap
**구현 계획:**
- **Phase 1**: 기본 인프라 구축 (1-2개월)
- **Phase 2**: 핵심 기능 개발 (2-3개월)
- **Phase 3**: 통합 및 테스트 (1개월)
- **Phase 4**: 출시 및 운영 (지속적)

**마일스톤:**
- MVP 개발 완료
- 베타 테스트 완료
- 정식 출시
- 운영 안정화

---

*이 문서는 사용자 입력 데이터를 바탕으로 생성되었습니다.*
*생성일: ${new Date().toLocaleDateString('ko-KR')}*
*프로젝트 ID: ${projectData.id}*`;
        }

        // TRD 표시
        function displayTRD(content) {
            document.getElementById('trdGenerating').style.display = 'none';
            document.getElementById('trdContentWrapper').style.display = 'block';
            document.getElementById('trdContent').innerHTML = convertMarkdownToHTML(content);
            document.getElementById('trdBadge').textContent = '생성 완료';
            document.getElementById('trdBadge').className = 'document-badge badge-generated';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // TRD 오류 표시
        function showTRDError(errorMessage) {
            document.getElementById('trdGenerating').style.display = 'none';
            document.getElementById('trdError').style.display = 'block';
            document.getElementById('trdErrorText').textContent = errorMessage;
        }

        // TRD 재생성
        async function regenerateTRD() {
            document.getElementById('trdContentWrapper').style.display = 'none';
            document.getElementById('trdGenerating').style.display = 'block';
            document.getElementById('trdBadge').textContent = '생성 중';
            document.getElementById('trdBadge').className = 'document-badge badge-generating';
            
            await generateTRD();
        }

        // TRD 재시도
        async function retryTRDGeneration() {
            document.getElementById('trdError').style.display = 'none';
            document.getElementById('trdGenerating').style.display = 'block';
            
            await generateTRD();
        }

        // 마크다운을 HTML로 변환 (간단한 구현)
        function convertMarkdownToHTML(markdown) {
            let html = markdown;
            
            // 헤딩
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h2>$1</h2>');
            
            // 볼드
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // 이탤릭
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // 리스트
            html = html.replace(/^\- (.*$)/gim, '<li>$1</li>');
            html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            
            // 줄바꿈
            html = html.replace(/\n\n/g, '</p><p>');
            html = '<p>' + html + '</p>';
            
            return html;
        }

        // TRD 건너뛰기
        function skipToComplete() {
            projectData.updateStatus('completed');
            document.getElementById('prdScreen').classList.remove('active');
            document.getElementById('finalCompletionScreen').classList.add('active');
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // 프로젝트 완료
        function completeProject() {
            projectData.approveDocument('trd');
            projectData.updateStatus('completed');
            
            document.getElementById('trdScreen').classList.remove('active');
            document.getElementById('finalCompletionScreen').classList.add('active');
            
            document.getElementById('trdBadge').textContent = '승인됨';
            document.getElementById('trdBadge').className = 'document-badge badge-approved';
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            console.log('🎉 프로젝트 완료!', projectData.getSummary());
        }

        // 데모 데이터 생성 (테스트용)
        function generateDemoData() {
            const demoBRD = `# Business Requirements Document

## 1. Executive Summary
이 프로젝트는 AI 기반 리뷰 검증 시스템을 통해 온라인 쇼핑의 신뢰성을 높이는 것을 목표로 합니다.

## 2. Business Objectives
- 가짜 리뷰 탐지율 95% 이상 달성
- 사용자 구매 전환율 30% 향상
- 플랫폼 신뢰도 지수 4.5/5 이상

## 3. Market Analysis
- 온라인 쇼핑 시장 규모: 연 500조원
- 가짜 리뷰로 인한 손실: 연 50조원
- 타겟 고객: 20-40대 온라인 쇼핑 이용자

## 4. Problem Statement
현재 온라인 쇼핑에서 가짜 리뷰로 인한 신뢰성 문제가 심각합니다.

## 5. Proposed Solution
AI 기반 리뷰 검증 시스템을 통해 실제 구매자만의 검증된 리뷰를 제공합니다.

## 6. Success Criteria
- 월간 활성 사용자 5만명
- 리뷰 신뢰도 평가 4.5/5 이상
- 구매 전환율 30% 향상

## 7. Stakeholders
- 제품 관리자
- 개발팀
- 마케팅팀
- 고객 서비스팀

## 8. Constraints & Risks
- 개발 기간: 6개월
- 예산: 5억원
- 기술적 복잡성

## 9. Timeline & Milestones
- 1단계: 프로토타입 개발 (2개월)
- 2단계: 베타 테스트 (1개월)
- 3단계: 정식 출시 (3개월)

## 10. Budget & Resources
- 개발비: 3억원
- 마케팅비: 1억원
- 운영비: 1억원`;

            const demoPRD = `# Product Requirements Document

## 1. Product Overview
AI 기반 리뷰 검증 시스템으로 온라인 쇼핑의 신뢰성을 높이는 제품입니다.

## 2. User Personas
- **주니어 쇼핑족**: 20-30대, 온라인 쇼핑 빈번
- **가족 쇼핑족**: 30-40대, 가족용품 구매
- **프리미엄 쇼핑족**: 30-50대, 고가 제품 구매

## 3. Feature Requirements
- **P0**: 리뷰 검증 알고리즘
- **P0**: 구매 이력 확인
- **P1**: 신뢰도 점수 표시
- **P1**: 검증 배지 시스템

## 4. User Stories
- 사용자는 구매한 제품에 대한 리뷰를 작성할 수 있다
- 사용자는 리뷰의 신뢰도를 확인할 수 있다
- 사용자는 검증된 리뷰를 우선적으로 볼 수 있다

## 5. User Experience
- 직관적인 리뷰 작성 인터페이스
- 명확한 신뢰도 표시
- 빠른 검증 프로세스

## 6. Functional Requirements
- 리뷰 텍스트 분석
- 구매 이력 매칭
- 신뢰도 점수 계산
- 검증 배지 부여

## 7. Non-Functional Requirements
- 응답 시간: 2초 이내
- 가용성: 99.9%
- 보안: 개인정보 보호

## 8. Data Requirements
- 구매 이력 데이터
- 리뷰 텍스트 데이터
- 사용자 프로필 데이터

## 9. Integration Requirements
- 쇼핑몰 API 연동
- 결제 시스템 연동
- 사용자 인증 시스템

## 10. Success Metrics
- 리뷰 검증 정확도: 95%
- 사용자 만족도: 4.5/5
- 시스템 가용성: 99.9%`;

            const demoTRD = `# Technical Requirements Document

## 1. Technical Overview
마이크로서비스 아키텍처 기반의 AI 리뷰 검증 시스템입니다.

## 2. System Architecture
- **Frontend**: React.js + TypeScript
- **Backend**: Node.js + Express
- **AI Engine**: Python + TensorFlow
- **Database**: PostgreSQL + Redis

## 3. Technology Stack
- **Frontend**: React, TypeScript, Material-UI
- **Backend**: Node.js, Express, TypeScript
- **AI/ML**: Python, TensorFlow, scikit-learn
- **Database**: PostgreSQL, Redis
- **Infrastructure**: Docker, Kubernetes

## 4. Data Architecture
- **PostgreSQL**: 사용자 데이터, 구매 이력
- **Redis**: 세션, 캐시
- **MongoDB**: 리뷰 텍스트 데이터
- **S3**: 파일 저장소

## 5. API Design
- **RESTful API**: 표준 HTTP 메서드
- **인증**: JWT 토큰 기반
- **Rate Limiting**: 1000 req/min
- **API 버전**: v1

## 6. Security Requirements
- **인증**: JWT + OAuth 2.0
- **암호화**: AES-256
- **HTTPS**: TLS 1.3
- **데이터 보호**: GDPR 준수

## 7. Performance Requirements
- **응답 시간**: 2초 이내
- **처리량**: 1000 req/sec
- **동시 사용자**: 10,000명
- **최적화**: CDN, 캐싱

## 8. Scalability & Availability
- **로드 밸런싱**: Nginx
- **자동 스케일링**: Kubernetes HPA
- **장애 복구**: Multi-AZ 배포
- **모니터링**: Prometheus + Grafana

## 9. Development Guidelines
- **코딩 컨벤션**: ESLint + Prettier
- **Git 워크플로우**: GitFlow
- **테스팅**: Jest + Cypress
- **CI/CD**: GitHub Actions

## 10. Implementation Roadmap
- **Phase 1**: 기본 인프라 구축 (2개월)
- **Phase 2**: AI 모델 개발 (2개월)
- **Phase 3**: 통합 및 테스트 (2개월)`;

            // 데모 데이터를 프로젝트에 저장
            projectData.completeDocumentGeneration('brd', demoBRD);
            projectData.completeDocumentGeneration('prd', demoPRD);
            projectData.completeDocumentGeneration('trd', demoTRD);
            
            console.log('🎯 데모 데이터 생성 완료!');
            alert('✅ 데모 데이터가 생성되었습니다!\n\n이제 PDF 저장 기능을 테스트할 수 있습니다.');
        }

        // 이벤트 리스너 설정
        document.addEventListener('DOMContentLoaded', function() {
            // 저장된 데이터 불러오기
            loadSavedData();
            
            // 각 textarea에 이벤트 리스너 추가
            const fields = ['insight', 'validation', 'capability', 'principle', 'success', 'feature'];
            fields.forEach(fieldId => {
                const textarea = document.getElementById(fieldId);
                textarea.addEventListener('input', () => updateCharCount(fieldId));
                textarea.addEventListener('blur', autoSave);
            });

            // 초기 진행률 업데이트
            updateProgress();
            updateNextButton();

            // 개발자 도구용 전역 함수 노출
            window.projectData = projectData;
            window.resetProject = resetProject;
            window.downloadProjectData = downloadProjectData;
            window.generateDemoData = generateDemoData;
            
            console.log('🎯 제품 문서 생성 시스템 초기화 완료');
            console.log('💡 개발자 도구 명령어:');
            console.log('  - projectData: 현재 프로젝트 데이터 확인');
            console.log('  - projectData.getSummary(): 프로젝트 요약');
            console.log('  - downloadProjectData(): JSON 파일로 내보내기');
            console.log('  - resetProject(): 데이터 초기화');
            console.log('  - generateDemoData(): 데모 데이터 생성 (PDF 테스트용)');
        });

        // PDF 내보내기 함수들
        function exportBRDtoPDF() {
            downloadAsFile(projectData.documents.brd.content, 'BRD', 'md');
        }

        function exportPRDtoPDF() {
            downloadAsFile(projectData.documents.prd.content, 'PRD', 'md');
        }

        function exportTRDtoPDF() {
            downloadAsFile(projectData.documents.trd.content, 'TRD', 'md');
        }

        function downloadAsFile(content, docType, extension) {
            if (!content || content.trim() === '') {
                alert(`⚠️ ${docType} 문서가 아직 생성되지 않았습니다.\n먼저 문서를 생성해주세요.`);
                return;
            }

            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${docType}_${projectData.id}_${Date.now()}.${extension}`;
            link.click();
            URL.revokeObjectURL(url);
            
            console.log(`✅ ${docType} 다운로드 완료:`, link.download);
        }

        // 문서 복사 기능
        function copyBRD() {
            copyToClipboard(projectData.documents.brd.content, 'BRD');
        }

        function copyPRD() {
            copyToClipboard(projectData.documents.prd.content, 'PRD');
        }

        function copyTRD() {
            copyToClipboard(projectData.documents.trd.content, 'TRD');
        }

        function copyToClipboard(text, docType) {
            if (!text || text.trim() === '') {
                alert(`⚠️ ${docType} 문서가 아직 생성되지 않았습니다.\n먼저 문서를 생성해주세요.`);
                return;
            }

            navigator.clipboard.writeText(text).then(() => {
                alert(`✓ ${docType}가 클립보드에 복사되었습니다!`);
                console.log(`✅ ${docType} 복사 완료`);
            }).catch(err => {
                console.error('복사 실패:', err);
                alert('복사에 실패했습니다. 다시 시도해주세요.');
            });
        }

        // 모든 문서 다운로드
        function downloadAllDocuments() {
            let downloadCount = 0;
            
            // BRD
            if (projectData.documents.brd.status !== 'pending' && projectData.documents.brd.content) {
                downloadAsFile(projectData.documents.brd.content, 'BRD', 'md');
                downloadCount++;
            }
            
            // PRD
            if (projectData.documents.prd.status !== 'pending' && projectData.documents.prd.content) {
                setTimeout(() => {
                    downloadAsFile(projectData.documents.prd.content, 'PRD', 'md');
                }, 300);
                downloadCount++;
            }
            
            // TRD
            if (projectData.documents.trd.status !== 'pending' && projectData.documents.trd.content) {
                setTimeout(() => {
                    downloadAsFile(projectData.documents.trd.content, 'TRD', 'md');
                }, 600);
                downloadCount++;
            }
            
            // 프로젝트 데이터 JSON
            setTimeout(() => {
                const dataStr = projectData.exportJSON();
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `project_data_${projectData.id}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }, 900);
            
            if (downloadCount > 0) {
                alert(`📦 ${downloadCount}개 문서를 다운로드합니다.\n\n다운로드 폴더를 확인해주세요.`);
            } else {
                alert('⚠️ 다운로드할 문서가 없습니다.\n먼저 문서를 생성해주세요.');
            }
        }

        // 새 프로젝트 시작
        function startNewProject() {
            if (confirm('🔄 새 프로젝트를 시작하시겠습니까?\n\n현재 프로젝트는 로컬 저장소에 보관됩니다.')) {
                // 현재 프로젝트를 백업
                const backup = projectData.exportJSON();
                localStorage.setItem(`project_backup_${projectData.id}`, backup);
                
                // 새 프로젝트 생성
                projectData = new ProjectData();
                localStorage.setItem('projectData', JSON.stringify(projectData));
                
                // 페이지 새로고침
                location.reload();
            }
        }

        // 데이터 초기화 함수 (개발/테스트용)
        function resetProject() {
            if (confirm('⚠️ 모든 데이터를 초기화하시겠습니까?')) {
                localStorage.clear();
                projectData = new ProjectData();
                location.reload();
            }
        }

        // 데이터 내보내기 함수 (개발/테스트용)
        function downloadProjectData() {
            const dataStr = projectData.exportJSON();
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `project_${projectData.id}_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // 키보드 단축키
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                if (!document.getElementById('nextBtn').disabled) {
                    nextStep();
                }
            }
            
            // 개발자 단축키: Ctrl+Shift+D로 데이터 다운로드
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                downloadProjectData();
            }
            
            // 개발자 단축키: Ctrl+Shift+R로 데이터 리셋
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                resetProject();
            }
        });
    </script>
</body>
</html>
